<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>jumpscale.sals.fs.fs API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.sals.fs.fs</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import sys
import re
import os
import hashlib
import fnmatch
import inspect  # needed for getPathOfRunningFunction
import shutil
import tempfile
import codecs
import pickle as pickle
import stat
from stat import ST_MTIME
import stat
from functools import wraps
import copy
from jumpscale.god import j


def copy_file(filefrom, to, create_dir_ifneeded=False, overwritefile=True):
    &#34;&#34;&#34; Copy File.

    Args:
        fileFrom (str): Source file path name.
        to (str):  Destination file or folder path name.
        create_dir_ifneeded (bool): Defaults to False.
        overwritefile (bool):  Defaults to True.
        &#34;&#34;&#34;
    # Create target folder first, otherwise copy fails
    target_folder = os.path.dirname(to)
    if create_dir_ifneeded:
        create_dir(target_folder)
    if exists(to):
        if os.path.samefile(filefrom, to):
            raise RuntimeError(&#34;{src} and {dest} are the same file&#34;.format(src=filefrom, dest=to))
        if overwritefile is False:
            if os.path.samefile(to, target_folder):
                destfilename = os.path.join(to, os.path.basename(filefrom))
                if exists(destfilename):
                    return
            else:
                return
        elif is_file(to):
            # overwriting some open  files is frustrating and may not work
            # due to locking [delete/copy is a better strategy]
            remove(to)
    shutil.copy(filefrom, to)


def move_file(source, destin):
    &#34;&#34;&#34; Move a  File from source path to destination path.

    Args:
        source (str): Source File Path.
        destin (str): Destination Path The File Should Be Moved to.
    &#34;&#34;&#34;
    _move(source, destin)


def rename_file(filepath, new_name):
    &#34;&#34;&#34; Rename File.

    Args:
        filepath (str): Path of the file.
        new_name (str): New name of the file.

    Returns:
        str: File path + New name
    &#34;&#34;&#34;
    return _move(filepath, new_name)


def remove_irrelevant_files(path, followsymlinks=True):
    &#34;&#34;&#34; Will remove files having extensions: pyc, bak.

    Args:
        path (str): path to search in.
        followsymlinks (bool): Defaults to True.
    &#34;&#34;&#34;
    ext = [&#34;pyc&#34;, &#34;bak&#34;]
    for path in list_files_in_dir(path, recursive=True, followsymlinks=followsymlinks):
        if get_file_extension(path) in ext:
            remove(path)


def remove(path):
    &#34;&#34;&#34; Remove a File.

    Args:
        path (str): File path required to be removed.

    Returns:
        str: delete path
    &#34;&#34;&#34;
    return os.remove(path)


def create_empty_file(filename):
    &#34;&#34;&#34; Create An Empty File.

  Args:
      filename (str): file path name to be created
  &#34;&#34;&#34;
    open(filename, &#34;w&#34;).close()


def create_dir(newdir, unlink=False):
    &#34;&#34;&#34; Create New Directory.

    Args:
        newdir (str): Directory path/name.
        unlink (bool): Defaults to False.

    &#34;&#34;&#34;
    if newdir.find(&#34;file://&#34;) != -1:
        raise RuntimeError(&#34;Cannot use file notation here&#34;)

    if exists(newdir):
        if is_link(newdir) and unlink:
            unlink(newdir)
    else:
        head, tail = os.path.split(newdir)
        if head and (not exists(head) or not is_dir(head)):
            create_dir(head, unlink=False)
        if tail:
            os.mkdir(newdir)
            # try:
            #     os.mkdir(newdir)
            #     # print &#34;mkdir:%s&#34;%newdir
            # except OSError as e:
            #     if e.errno != os.errno.EEXIST:  # File exists
            #         raise


def copy_dir_tree(src, dst, symlinks=False, ignore=None):
    &#34;&#34;&#34; Copy Tree Directory.

    Args:
        src (str): Source of tree directory.
        dst (str): destination of directory.
        symlinks (bool): Defaults to False.
        ignore (Nonetype): Defaults to None.
    &#34;&#34;&#34;
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            shutil.copytree(s, d, symlinks, ignore)
        else:
            shutil.copy2(s, d)


def change_dir(path):
    &#34;&#34;&#34; Changes Current Directory.

    Args:
        path (str): Directory path to be changed to.

    Returns:
        str: Current path
    &#34;&#34;&#34;
    os.chdir(path)
    current_path = os.getcwd()

    return current_path


def move_dir(source, destin):
    &#34;&#34;&#34; Move Directory from source to destination.

    Args:
        source (str): Source path where the directory should be removed from
        destin (str): Destination path where the directory should be moved into
    &#34;&#34;&#34;
    _move(source, destin)


def join_path(*args):
    &#34;&#34;&#34; Join one or more path components.

    Returns:
        str: Join two or more pathname components.
    &#34;&#34;&#34;
    args = [str(x) for x in args]

    if args is None:
        raise RuntimeError(&#34;Not enough parameters %s&#34; % (str(args)))
    if os.sys.platform.startswith(&#34;win&#34;):
        args2 = []
        for item in args:
            item = item.replace(&#34;/&#34;, &#34;\\&#34;)
            while len(item) &gt; 0 and item[0] == &#34;\\&#34;:
                item = item[1:]
            args2.append(item)
        args = args2
    return os.path.join(*args)


def get_dir_name(path, lastonly=False, levelsup=None):
    &#34;&#34;&#34; Return a directory name from pathname path.

    Args:
        path (str): The path to find a directory.
        lastonly (bool): Means only the last part of the path which is a dir (overrides levelsup to 0).Defaults to False.
        levelsup (NoneType): Means return the parent dir levelsup levels up. Defaults to None.

    Returns:
        str: dname + os.sep
    &#34;&#34;&#34;

    dname = os.path.dirname(path)
    dname = dname.replace(&#34;/&#34;, os.sep)
    dname = dname.replace(&#34;//&#34;, os.sep)
    dname = dname.replace(&#34;\\&#34;, os.sep)
    if lastonly:
        dname = dname.split(os.sep)[-1]
        return dname
    if levelsup is not None:
        parts = dname.split(os.sep)
        if len(parts) - levelsup &gt; 0:
            return parts[len(parts) - levelsup - 1]
        else:
            raise RuntimeError(&#34;Cannot find part of dir %s levels up, path %s is not long enough&#34; % (levelsup, path))
    return dname + os.sep if dname else dname


def get_base_name(path, remove_extension=False):
    &#34;&#34;&#34; Return the base name of pathname path.

    Args:
        path (str): the path of the base name
        remove_extension (bool): Defaults to False.

    Returns:
        str: name
    &#34;&#34;&#34;
    name = os.path.basename(path.rstrip(os.path.sep))
    if remove_extension:
        if &#34;.&#34; in name:
            name = &#34;.&#34;.join(name.split(&#34;.&#34;)[:-1])
    return name
    basename = get_base_name


def path_clean(path):
    &#34;&#34;&#34; Clean path.

    Args:
        path (str): source of the path of dir

    Returns:
        str: normcase path
    &#34;&#34;&#34;

    return path.replace(&#34;\\&#34;, os.sep).replace(&#34;/&#34;, os.sep).lower()


def path_dir_clean(path):
    &#34;&#34;&#34; Clean Path Directory.

    Args:
        path (str): source of the path of dir

    Returns:
        str: normcase path
    &#34;&#34;&#34;
    return os.path.normpath(path)


# NO DECORATORS HERE
def path_normalize(path):
    &#34;&#34;&#34; Normalize Path

    Args:
        path (str): The path to be normalize

    Returns:
        str: Return the absolute version of a path.
    &#34;&#34;&#34;
    return os.path.normpath(path)


def path_remove_dir_part(path, toremove, remove_trailing_slash=False):
    &#34;&#34;&#34;
    goal remove dirparts of a dirpath e,g, a basepath which is not needed
    will look for part to remove in full path but only full dirs
    &#34;&#34;&#34;
    path = path_normalize(path)
    toremove = path_normalize(toremove)

    if path_clean(toremove) == path_clean(path):
        return &#34;&#34;
    path = path_clean(path)
    path = path.replace(path_dir_clean(toremove), &#34;&#34;)
    if remove_trailing_slash:
        if len(path) &gt; 0 and path[0] == os.sep:
            path = path[1:]
    path = path_clean(path)
    path = path_normalize(path)
    return path


def process_path_for_double_dots(path):
    &#34;&#34;&#34; double dots process.

    Args:
        path (str): the path for double dots process.

    Returns:
        str:
    &#34;&#34;&#34;

    # print &#34;process_path_for_double_dots:%s&#34;%path
    path = path_clean(path)
    path = path.replace(&#34;\\&#34;, &#34;/&#34;)
    result = []
    for item in path.split(&#34;/&#34;):
        if item == &#34;..&#34;:
            if result == []:
                raise RuntimeError(&#34;Cannot process_path_for_double_dots for paths with only ..&#34;)
            else:
                result.pop()
        else:
            result.append(item)
    return &#34;/&#34;.join(result)


def get_parent(path):
    &#34;&#34;&#34;Returns the parent of the path.

    Args:
        path (str): source path to get the parent.

    Returns:
        str: the parent of the path
    &#34;&#34;&#34;
    parts = path.split(os.sep)
    if parts[-1] == &#34;&#34;:
        parts = parts[:-1]
    parts = parts[:-1]
    if parts == [&#34;&#34;]:
        return os.sep
    return os.sep.join(parts)


def get_parent_with_dir_name(path=&#34;&#34;, dirname=&#34;.git&#34;, die=False):
    &#34;&#34;&#34; looks for parent which has dirname in the parent directory.

    Args:
        path (str): Defaults to &#34;&#34;.
        dirname (str): Defaults to &#34;.git&#34;.
        die (bool): Defaults to False.

    Returns:
    str: the path which has the dirname or None
    &#34;&#34;&#34;

    if path == &#34;&#34;:
        path = getcwd()

    # first check if there is no .jsconfig in parent dirs
    curdir = copy.copy(path)
    while curdir.strip() != &#34;&#34;:
        if exists(&#34;%s/%s&#34; % (curdir, dirname)):
            return curdir
        # look for parent
        curdir = get_parent(curdir)
    if die:
        raise Exception(&#34;Could not find %s dir as parent of:&#39;%s&#39;&#34; % (dirname, path))
    else:
        return None


def get_file_extension(path):
    &#34;&#34;&#34; Returns the extension of the file.

    Args:
        path (str): the path of file extension.

    Returns:
        str: file extension.
    &#34;&#34;&#34;
    ext = os.path.splitext(path)[1]
    return ext.strip(&#34;.&#34;)


def chown(path, user, group=None):
    &#34;&#34;&#34;

    Args:
        path (str):
        user (str):
        group (NoneType): [description]. Defaults to None.
    &#34;&#34;&#34;
    from pwd import getpwnam
    from grp import getgrnam

    getpwnam(user)[2]
    uid = getpwnam(user).pw_uid
    if group is not None:
        gid = getgrnam(group).gr_gid
    else:
        gid = getpwnam(user).pw_gid
    os.chown(path, uid, gid)
    for root, dirs, files in os.walk(path):
        for ddir in dirs:
            path = os.path.join(root, ddir)
            try:
                os.chown(path, uid, gid)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise Exception(&#34;No such file or directory&#34;)
        for file in files:
            path = os.path.join(root, file)
            try:
                os.chown(path, uid, gid)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise Exception(&#34;No such file or directory&#34;)


def chmod(path, permissions):
    &#34;&#34;&#34; Change the file mode bits of each given file according to mode.

    Args:
        path (str): The path of the file.
        permissions (str): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if permissions &gt; 511 or permissions &lt; 0:
        raise RuntimeError(&#34;can&#39;t perform chmod, %s is not a valid mode&#34; % oct(permissions))

    os.chmod(path, permissions)
    for root, dirs, files in os.walk(path):
        for ddir in dirs:
            path = os.path.join(root, ddir)
            try:
                os.chmod(path, permissions)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise RuntimeError(&#34;%s&#34; % e)

        for file in files:
            path = os.path.join(root, file)
            try:
                os.chmod(path, permissions)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise RuntimeError(&#34;%s&#34; % e)


def getcwd():
    &#34;&#34;&#34; Get Current working Directory.

    Returns:
        str: current working directory path.
    &#34;&#34;&#34;
    return os.getcwd()


def read_link(path):
    &#34;&#34;&#34; Read links

    Args:
        path (str): [description]

    Returns:
        str: res
    &#34;&#34;&#34;

    while path[-1] == &#34;/&#34; or path[-1] == &#34;\\&#34;:
        path = path[:-1]

    if j.data.platform.is_linux() or j.data.platform.is_osx():
        res = os.readlink(path)
    elif j.data.platform.is_windows():
        raise RuntimeError(&#34;Cannot read_link on windows&#34;)
    else:
        raise RuntimeError(&#34;cant read link, dont understand platform&#34;)

    if res.startswith(&#34;..&#34;):
        srcDir = get_dir_name(path)
        res = path_normalize(&#34;%s%s&#34; % (srcDir, res))
    elif get_base_name(res) == res:
        res = join_path(get_parent(path), res)
    return res


def remove_links(path):
    &#34;&#34;&#34; Remove all links.

    Args:
        path (str): the path of the link
    &#34;&#34;&#34;
    items = _list_all_in_dir(path=path, recursive=True, followsymlinks=False, listsymlinks=True)
    items = [item for item in items[0] if is_link(item)]
    for item in items:
        unlink(item)


def _list_in_dir(path, followsymlinks=True):
    &#34;&#34;&#34; List is Directory.

    Args:
        path (str): Directory path to list.
        followsymlinks (bool): Defaults to True.

    Returns:
        str: names
    &#34;&#34;&#34;

    names = os.listdir(path)
    return names


def list_files_in_dir(
    path,
    recursive=False,
    filter=None,
    minmtime=None,
    maxmtime=None,
    depth=None,
    case_sensitivity=&#34;os&#34;,
    exclude=[],
    followsymlinks=False,
    listsymlinks=False,
):
    &#34;&#34;&#34; List of files in directory.

    Returns:
      str: list of files
    &#34;&#34;&#34;
    if depth is not None:
        depth = int(depth)

    if depth == 0:
        depth = None
    # if depth is not None:
    #     depth+=1
    filesreturn, depth = _list_all_in_dir(
        path,
        recursive,
        filter,
        minmtime,
        maxmtime,
        depth,
        type=&#34;f&#34;,
        case_sensitivity=case_sensitivity,
        exclude=exclude,
        followsymlinks=followsymlinks,
        listsymlinks=listsymlinks,
    )
    return filesreturn


def list_files_and_dirs_in_dir(
    path,
    recursive=True,
    filter=None,
    minmtime=None,
    maxmtime=None,
    depth=None,
    type=&#34;fd&#34;,
    followsymlinks=False,
    listsymlinks=False,
):

    &#34;&#34;&#34;Retrieves list of files found in the specified directory.

   Returns:
       str: Return Files.
    &#34;&#34;&#34;
    if depth is not None:
        depth = int(depth)

    if depth == 0:
        depth = None
    # if depth is not None:
    #     depth+=1
    filesreturn, _ = _list_all_in_dir(
        path,
        recursive,
        filter,
        minmtime,
        maxmtime,
        depth,
        type=type,
        followsymlinks=followsymlinks,
        listsymlinks=listsymlinks,
    )
    return filesreturn


def _list_all_in_dir(
    path,
    recursive,
    filter=None,
    minmtime=None,
    maxmtime=None,
    depth=None,
    type=&#34;df&#34;,
    case_sensitivity=&#34;os&#34;,
    exclude=[],
    followsymlinks=True,
    listsymlinks=True,
):
    &#34;&#34;&#34;

    Returns:
        [type]: return files
    &#34;&#34;&#34;

    dircontent = _list_in_dir(path)
    filesreturn = []

    if case_sensitivity.lower() == &#34;sensitive&#34;:
        matcher = fnmatch.fnmatchcase
    elif case_sensitivity.lower() == &#34;insensitive&#34;:

        def matcher(fname, pattern):
            return fnmatch.fnmatchcase(fname.lower(), pattern.lower())

    else:
        matcher = fnmatch.fnmatch

    for direntry in dircontent:
        fullpath = join_path(path, direntry)

        if is_link_and_broken(fullpath):
            continue

        if followsymlinks:
            if is_link(fullpath):
                fullpath = read_link(fullpath)

        if is_file(fullpath) and &#34;f&#34; in type:
            includeFile = False
            if (filter is None) or matcher(direntry, filter):
                if (minmtime is not None) or (maxmtime is not None):
                    mymtime = os.stat(fullpath)[ST_MTIME]
                    if (minmtime is None) or (mymtime &gt; minmtime):
                        if (maxmtime is None) or (mymtime &lt; maxmtime):
                            includeFile = True
                else:
                    includeFile = True
            if includeFile:
                if exclude != []:
                    for excludeItem in exclude:
                        if matcher(direntry, excludeItem):
                            includeFile = False
                if includeFile:
                    filesreturn.append(fullpath)
        elif is_dir(fullpath):
            if &#34;d&#34; in type:
                # if not(listsymlinks==False and is_link(fullpath)):
                filesreturn.append(fullpath)
            if recursive:
                newdepth = depth
                if newdepth is not None and newdepth != 0:
                    newdepth = newdepth - 1
                if newdepth is None or newdepth != 0:
                    exclmatch = False
                    if exclude != []:
                        for excludeItem in exclude:
                            if matcher(fullpath, excludeItem):
                                exclmatch = True
                    if exclmatch is False:
                        if not (followsymlinks is False and is_link(fullpath, check_valid=True)):
                            r, _ = _list_all_in_dir(
                                fullpath,
                                recursive,
                                filter,
                                minmtime,
                                maxmtime,
                                depth=newdepth,
                                type=type,
                                exclude=exclude,
                                followsymlinks=followsymlinks,
                                listsymlinks=listsymlinks,
                            )
                            if len(r) &gt; 0:
                                filesreturn.extend(r)
        # and followsymlinks==False and listsymlinks:
        elif is_link(fullpath) and followsymlinks == False and listsymlinks:
            filesreturn.append(fullpath)

    return filesreturn, depth


def get_path_of_running_function(function):
    &#34;&#34;&#34; Get Path of Running Function.

    Args:
        function (str): [description]

    Returns:
        str: getfile
    &#34;&#34;&#34;
    return inspect.getfile(function)


def change_file_names(
    toreplace, replacewidth, pathtosearchin, recursive=True, filter=None, minmtime=None, maxmtime=None
):
    &#34;&#34;&#34; Change File Names.

Args:
    toreplace (str): [description]
    replacewidth (str): [description]
    pathtosearchin (str): [description]
    recursive (bool): [description]. Defaults to True.
    filter (NoneType): [description]. Defaults to None.
    minmtime (NoneType): [description]. Defaults to None.
    maxmtime (NoneType): [description]. Defaults to None.

Returns:
    [type]: [description]
&#34;&#34;&#34;

    if not toreplace:
        raise RuntimeError(&#34;Can&#39;t change file names, toreplace can&#39;t be empty&#34;)
    if not replacewidth:
        raise RuntimeError(&#34;Can&#39;t change file names, replacewidth can&#39;t be empty&#34;)
    paths = list_files_in_dir(pathtosearchin, recursive, filter, minmtime, maxmtime)
    for path in paths:
        dir_name = get_dir_name(path)
        file_name = get_base_name(path)
        new_file_name = file_name.replace(toreplace, replacewidth)
        if new_file_name != file_name:
            new_path = join_path(dir_name, new_file_name)
            rename_file(path, new_path)


def replace_words_in_files(pathtosearchin, templateengine, recursive=True, filter=None, minmtime=None, maxmtime=None):
    &#34;&#34;&#34; Replace words in files.

    Args:
        pathtosearchin (str):
        templateengine (str): [description]
        recursive (bool): [description]. Defaults to True.
        filter (NoneType): [description]. Defaults to None.
        minmtime (NoneType): [description]. Defaults to None.
        maxmtime (NoneType): [description]. Defaults to None.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    paths = list_files_in_dir(pathtosearchin, recursive, filter, minmtime, maxmtime)
    for path in paths:
        templateengine.replaceInsideFile(path)


def list_dirs_in_dir(path, recursive=False, dirnameonly=False, finddirectorysymlinks=True, followsymlinks=True):
    &#34;&#34;&#34; Retrieves list of directories found in the specified directory.

    Args:
        path (str): represents directory path to search in.
        recursive (bool): [description]. Defaults to False.
        dirnameonly (bool): [description]. Defaults to False.
        finddirectorysymlinks (bool): [description]. Defaults to True.
        followsymlinks (bool): [description]. Defaults to True.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    items = _list_in_dir(path)
    filesreturn = []
    for item in items:
        fullpath = os.path.join(path, item)
        if item.startswith(&#34;Icon&#34;):
            continue
        if is_dir(fullpath, finddirectorysymlinks):
            if dirnameonly:
                filesreturn.append(item)
            else:
                filesreturn.append(fullpath)
        if recursive and is_dir(fullpath, followsymlinks):
            if is_link(fullpath):
                fullpath = read_link(fullpath)
            filesreturn.extend(
                list_dirs_in_dir(
                    fullpath,
                    recursive=recursive,
                    dirnameonly=dirnameonly,
                    finddirectorysymlinks=finddirectorysymlinks,
                    followsymlinks=followsymlinks,
                )
            )
    return filesreturn


def list_py_scripts_in_dir(path, recursive=True, filter=&#34;*.py&#34;):
    &#34;&#34;&#34; Retrieves list of python scripts (with extension .py) in the specified directory

    Args:
        path (str): Represents the directory path.
        recursive (bool): [description]. Defaults to True.
        filter (str): [description]. Defaults to &#34;*.py&#34;.

    Returns:
        str: result
    &#34;&#34;&#34;
    result = []
    for file in list_files_in_dir(path, recursive=recursive, filter=filter):
        if file.endswith(&#34;.py&#34;):
            # filename = file.split(os.sep)[-1]
            # scriptname = filename.rsplit(&#34;.&#34;, 1)[0]
            result.append(file)
    return result


def _move(source, destin):
    &#34;&#34;&#34; Move function.

    Args:
        source (str): [description]
        destin (str): [description]

    Raises:
        j.exceptions.IO: [description]
    &#34;&#34;&#34;

    if not exists(source):
        raise RuntimeError(&#34;%s does not exist&#34; % source)
    shutil.move(source, destin)


def exists(path, followlinks=True):
    &#34;&#34;&#34; Check if the specified path exists.

    Args:
        path (str): [description]
        followlinks (bool): [description]. Defaults to True.

    Raises:
        j.exceptions.Value: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if path is None:
        raise RuntimeError(&#34;Path is not passed in system.fs.exists&#34;)

    found = False
    try:
        st = os.lstat(path)
        found = True
    except (OSError, AttributeError):
        pass
    if found and followlinks and stat.S_ISLNK(st.st_mode):

        relativelink = read_link(path)
        newpath = join_path(get_parent(path), relativelink)
        return exists(newpath)
    if found:
        return True

    return False


def symlink(path, target, overwritetarget=False):
    &#34;&#34;&#34; Create a symbolic link.

    Args:
        path (str): Source path desired to create symbolic link.
        target (str): destination path required to create the symbolic link.
        overwritetarget (bool): [description]. Defaults to False.
    &#34;&#34;&#34;
    if target[-1] == &#34;/&#34;:
        target = target[:-1]

    if overwritetarget and exists(target):
        if is_link(target):
            remove(target)
        elif is_dir(target):
            remove(target)
        else:
            remove(target)

    if os.path.islink(target):
        remove(target)

    dir = get_dir_name(target)
    if not exists(dir):
        create_dir(dir)

    if j.data.platform.is_linux() or j.data.platform.is_osx():
        try:
            os.symlink(path, target)
        except Exception as e:
            os.remove(target)
            os.symlink(path, target)

    elif j.data.platform.is_windows():
        path = path.replace(&#34;+&#34;, &#34;:&#34;)
        cmd = &#39;junction &#34;%s&#34; &#34;%s&#34;&#39; % (
            path_normalize(target).replace(&#34;\\&#34;, &#34;/&#34;),
            path_normalize(path).replace(&#34;\\&#34;, &#34;/&#34;),
        )
        print(cmd)


def symlink_files_in_dir(src, dest, delete=True, includedirs=False, makeexecutable=False):
    &#34;&#34;&#34;[summary]

    Args:
        src ([type]): [description]
        dest ([type]): [description]
        delete (bool, optional): [description]. Defaults to True.
        includedirs (bool, optional): [description]. Defaults to False.
        makeExecutable (bool, optional): [description]. Defaults to False.
    &#34;&#34;&#34;
    if includedirs:
        items = list_files_and_dirs_in_dir(src, recursive=False, followsymlinks=False, listsymlinks=False)
    else:
        items = list_files_in_dir(src, recursive=False, followsymlinks=True, listsymlinks=True)
    for item in items:
        dest2 = &#34;%s/%s&#34; % (dest, get_base_name(item))
        dest2 = dest2.replace(&#34;//&#34;, &#34;/&#34;)

        symlink(item, dest2, overwritetarget=delete)
        if makeexecutable:
            # print(&#34;executable:%s&#34; % dest2)
            chmod(dest2, 0o770)
            chmod(item, 0o770)


def hardlink_file(source, destin):
    &#34;&#34;&#34;[summary]

  Args:
      source ([type]): [description]
      destin ([type]): [description]

  Raises:
      j.exceptions.RuntimeError: [description]

  Returns:
      [type]: [description]
  &#34;&#34;&#34;

    if j.data.platform.is_linux() or j.data.platform.is_osx():
        return os.link(source, destin)
    else:
        raise RuntimeError(&#34;Cannot create a hard link on windows&#34;)


def check_dir_param(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Raises:
        j.exceptions.Value: [description]
        j.exceptions.RuntimeError: [description]
        j.exceptions.RuntimeError: [description]
        j.exceptions.Value: [description]
        j.exceptions.Value: [description]
        j.exceptions.Value: [description]
        Exception: [description]
        Exception: [description]
        j.exceptions.NotImplemented: [description]
        j.exceptions.RuntimeError: [description]

    Returns:
        [type]: [description]
&#34;&#34;&#34;

    if path.strip() == &#34;&#34;:
        raise RuntimeError(&#34;path parameter cannot be empty.&#34;)
    path = path_normalize(path)
    if path[-1] != &#34;/&#34;:
        path = path + &#34;/&#34;
    return path


&#34;&#34;&#34;Check if the specified Directory path exists
    @param path: string
    @param followsoftlink: boolean
    @rtype: boolean (True if directory exists)
    &#34;&#34;&#34;


def is_dir(path, followsoftlink=False):
    &#34;&#34;&#34;[summary]

 Args:
     path ([type]): [description]
     followsoftlink (bool, optional): [description]. Defaults to False.

 Returns:
     [type]: [description]
 &#34;&#34;&#34;

    if is_link(path):
        if not followsoftlink:
            return False
        path = read_link(path)
    return os.path.isdir(path)


def is_empty_dir(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if _list_in_dir(path) == []:

        return True

    return False


def is_file(path, followsoftlink=True):
    &#34;&#34;&#34;[summary]

 Args:
     path ([type]): [description]
     followsoftlink (bool, optional): [description]. Defaults to True.

 Returns:
     [type]: [description]
 &#34;&#34;&#34;

    if not followsoftlink and is_link(path):

        return True

    if os.path.isfile(path):

        return True

    return False


def is_executable(path):
    &#34;&#34;&#34;[summary]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    statobj = stat_path(path, follow_symlinks=False)
    return not (stat.S_IXUSR &amp; statobj.st_mode == 0)


def is_link_and_broken(path, remove_if_broken=True):
    &#34;&#34;&#34;[summary]

Args:
    path ([type]): [description]
    remove_if_broken (bool, optional): [description]. Defaults to True.

Raises:
    j.exceptions.RuntimeError: [description]
    j.exceptions.RuntimeError: [description]
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    Exception: [description]
    Exception: [description]
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;

    if os.path.islink(path):
        rpath = read_link(path)
        if not exists(rpath):
            if remove_if_broken:
                remove(path)
            return True
    return False

    &#34;&#34;&#34;Check if the specified path is a link
    @param path: string
    @rtype: boolean (True if the specified path is a link)

    @PARAM check_valid if True, will remove link if the dest is not there and return False
    &#34;&#34;&#34;


def is_link(path, checkjunction=False, check_valid=False):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]
        checkjunction (bool, optional): [description]. Defaults to False.
        check_valid (bool, optional): [description]. Defaults to False.

    Raises:
        j.exceptions.RuntimeError: [description]
        j.exceptions.RuntimeError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if path[-1] == os.sep:
        path = path[:-1]

    if checkjunction and j.data.platform.is_windows():
        cmd = &#34;junction %s&#34; % path
        try:
            result = []
            # result = j.sals.process.execute(cmd)
            pass
        except Exception as e:
            raise RuntimeError(&#34;Could not execute junction cmd, is junction installed? Cmd was %s.&#34; % cmd)
        if result[0] != 0:
            raise RuntimeError(&#34;Could not execute junction cmd, is junction installed? Cmd was %s.&#34; % cmd)
        if result[1].lower().find(&#34;substitute name&#34;) != -1:
            return True
        else:
            return False

    if os.path.islink(path):
        if check_valid:
            j.shell()
        return True

    return False


def is_mount(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Raises:
        j.exceptions.Value: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if path is None:
        raise RuntimeError(&#34;Path is passed null in system.fs.isMount&#34;)
    return os.path.ismount(path)


def stat_path(path, follow_symlinks=True):
    &#34;&#34;&#34;[summary]

Args:
    path ([type]): [description]
    follow_symlinks (bool, optional): [description]. Defaults to True.

Raises:
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    Exception: [description]
    Exception: [description]
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;
    return os.stat(path, follow_symlinks=follow_symlinks)


def rename_dir(dirname, newname, overwrite=False):
    &#34;&#34;&#34;[summary]

Args:
    dirname ([type]): [description]
    newname ([type]): [description]
    overwrite (bool, optional): [description]. Defaults to False.

Raises:
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    Exception: [description]
    Exception: [description]
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;
    if dirname == newname:
        return
    if overwrite and exists(newname):
        if is_dir(newname):
            remove(newname)
        else:
            remove(newname)
    os.rename(dirname, newname)


def unlink_file(filename):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]
    &#34;&#34;&#34;
    if j.data.platform.is_windows():
        cmd = &#34;junction -d %s 2&gt;&amp;1 &gt; null&#34; % (filename)
        # _log_info(cmd)
        os.system(cmd)
    os.unlink(filename)


def unlink(filename):
    &#34;&#34;&#34;Remove the given file if it&#39;s a file or a symlink
    @param filename: File path to be removed
    @type filename: string
    &#34;&#34;&#34;

    if j.data.platform.is_windows():
        cmd = &#34;junction -d %s 2&gt;&amp;1 &gt; null&#34; % (filename)
        # _log_info(cmd)
        os.system(cmd)
    os.unlink(filename)


def readfile(filename, binary=False, encoding=&#34;utf-8&#34;):
    &#34;&#34;&#34; Read a file and get contents of that file.

    Args:
        filename (str): filename to open for reading
        binary (bool):  Defaults to False.
        encoding (str):  Defaults to &#34;utf-8&#34;.

    Returns:
        str: data
    &#34;&#34;&#34;

    if binary:
        with open(filename, mode=&#34;rb&#34;) as fp:
            data = fp.read()
    else:
        with open(filename, encoding=encoding) as fp:
            data = fp.read()
    return data


def touch(paths):
    &#34;&#34;&#34;[summary]

   Args:
       paths ([type]): [description]
    &#34;&#34;&#34;
    if isinstance(paths, list):
        for item in paths:
            touch(item)
    else:
        path = paths
        create_dir(get_dir_name(path))
        if not exists(path=path):
            writefile(path, &#34;&#34;)


def writefile(filename, contents, append=False):
    &#34;&#34;&#34;[summary]

   Args:
       filename ([type]): [description]
       contents ([type]): [description]
       append (bool, optional): [description]. Defaults to False.

   Raises:
       j.exceptions.Value: [description]
    &#34;&#34;&#34;
    if contents is None:
        raise RuntimeError(&#34;Passed None parameters in system.fs.writefile&#34;)
    # filename = j.core.tools.text_replace(filename)
    if append is False:
        fp = open(filename, &#34;wb&#34;)
    else:
        fp = open(filename, &#34;ab&#34;)

    if isinstance(contents, str):
        fp.write(bytes(contents, &#34;UTF-8&#34;))
    else:
        fp.write(contents)
    # fp.write(contents)
    fp.close()


def file_size(filename):
    &#34;&#34;&#34; Get the size of the file in bytes.

    Args:
        filename (str): the name of the file that you want to know the size of it.

    Raises:
        j.exceptions.Value: [description]
        Exception: [description]
        Exception: [description]
        j.exceptions.NotImplemented: [description]
        j.exceptions.RuntimeError: [description]

    Returns:
        int : getsize filename
    &#34;&#34;&#34;
    return os.path.getsize(filename)


def write_object_to_file(filelocation, obj):
    &#34;&#34;&#34;write an object to a file

    Args:
        filelocation (str): location of the file.
        obj (str):

    Raises:
        j.exceptions.Value: [description]
        Exception: [description]
        Exception: [description]
    &#34;&#34;&#34;
    if not obj:
        raise RuntimeError(&#34;You should provide a filelocation or a object as parameters&#34;)

    try:
        pcl = pickle.dumps(obj)
    except Exception as e:
        raise Exception(&#34;Could not create pickle from the object \nError: %s&#34; % (str(e)))
    writefile(filelocation, pcl)
    if not exists(filelocation):
        raise Exception(&#34;File isn&#39;t written to the filesystem&#34;)


&#34;&#34;&#34;
    Read a object from a file(file contents in pickle format)
    @param filelocation: location of the file
    @return: object
    &#34;&#34;&#34;


def read_object_from_file(filelocation):
    &#34;&#34;&#34;[summary]

Args:
    filelocation ([type]): [description]

Raises:
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;

    file = os.open(filelocation)
    contents = file.readfile()
    file.close()
    return pickle.loads(contents)


&#34;&#34;&#34;Return the hex digest of a file without loading it all into memory
    @param filename: string (filename to get the hex digest of it) or list of files
    @rtype: md5 of the file
    &#34;&#34;&#34;


def md5sum(filename):
    &#34;&#34;&#34;[summary]

Args:
    filename ([type]): [description]

Raises:
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;

    if not isinstance(filename, list):
        filename = [filename]
    digest = hashlib.md5()
    for filepath in filename:
        with open(filepath, &#34;rb&#34;) as fh:
            while True:
                buf = fh.read(4096)
                if buf == b&#34;&#34;:
                    break
                digest.update(buf)
    return digest.hexdigest()


def get_folder_md5sum(folder):
    &#34;&#34;&#34;[summary]

    Args:
        folder ([type]): [description]

    Returns:
        str: md5sum files
    &#34;&#34;&#34;
    files = sorted(os.walk(folder))
    return md5sum(files)


def get_tmp_dir_path(name=&#34;&#34;, create=True):
    &#34;&#34;&#34;  create a tmp dir name and makes sure the dir exists

  Args:
      name (str): [description]. Defaults to &#34;&#34;.
      create (bool): [description]. Defaults to True.

  Returns:
      bool: tmpdir
  &#34;&#34;&#34;
    if name:
        tmpdir = join_path(j.dirs.TMPDIR, name)
    else:
        tmpdir = join_path(j.dirs.TMPDIR, j.data.idgenerator.generateXCharID(10))
    if create is True:
        create_dir(tmpdir)
    return tmpdir


def get_tmp_file_path(cygwin=False):
    &#34;&#34;&#34;Generate a temp file path

    Args:
        cygwin (bool): [description]. Defaults to False.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    tmpdir = j.dirs.TMPDIR + &#34;/jumpscale/&#34;
    j.sals.fs.create_dir(tmpdir)
    fd, path = tempfile.mkstemp(dir=tmpdir)
    try:
        real_fd = os.fdopen(fd)
        real_fd.close()
    except (IOError, OSError):
        pass
    if cygwin:
        path = path.replace(&#34;\\&#34;, &#34;/&#34;)
        path = path.replace(&#34;//&#34;, &#34;/&#34;)
    return path


def _file_path_tmp_get(ext=&#34;sh&#34;):
    &#34;&#34;&#34;[summary]

   Args:
       ext (str, optional): [description]. Defaults to &#34;sh&#34;.

   Returns:
       [type]: [description]
   &#34;&#34;&#34;
    return j.core.tools._file_path_tmp_get(ext)


def is_asxii_file(filename, checksize=4096):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]
        checksize (int, optional): [description]. Defaults to 4096.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    # TODO: let&#39;s talk about checksize feature.
    try:
        with open(filename, encoding=&#34;ascii&#34;) as f:
            f.read()
            return True
    except UnicodeDecodeError:
        return False


def is_binary_file(filename, checksize=4096):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]
        checksize (int, optional): [description]. Defaults to 4096.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return not is_asxii_file(filename, checksize)


def is_absolute(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return os.path.isabs(path)


# THERE IS A tools.lock implementation we need to use that one
# lock = staticmethod(lock)
# lock_ = staticmethod(lock_)
# islocked = staticmethod(islocked)
# unlock = staticmethod(unlock)
# unlock_ = staticmethod(unlock_)


def validate_filename(filename, platform=None):
    &#34;&#34;&#34; Validate a filename for a given (or current) platform.

    Args:
        filename (str): File name to check.
        platform (Nonetype): Platform to validate against. Defaults to None.

    Raises:
        j.exceptions.NotImplemented: [description]

    Returns:
        bool: Whether the filename is valid on the given platform
    &#34;&#34;&#34;
    platform = platform or j.core.platformtype.myplatform

    if not filename:
        return False

    # When adding more restrictions to check_unix or check_windows, please
    # update the validateFilename documentation accordingly


def check_unix(filename):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if len(filename) &gt; 255:
        return False

    if &#34;\0&#34; in filename or &#34;/&#34; in filename:
        return False

    return True


def check_windows(filename):
    &#34;&#34;&#34; Check windows

Args:
    filename (str):

Raises:
    j.exceptions.NotImplemented: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;
    if len(filename) &gt; 255:
        return False

    if os.path.splitext(filename)[0] in (&#34;CON&#34;, &#34;PRN&#34;, &#34;AUX&#34;, &#34;CLOCK$&#34;, &#34;NUL&#34;):
        return False

    if os.path.splitext(filename)[0] in (&#34;COM%d&#34; % i for i in range(1, 9)):
        return False

    if os.path.splitext(filename)[0] in (&#34;LPT%d&#34; % i for i in range(1, 9)):
        return False

    # ASCII characters 0x00 - 0x1F are invalid in a Windows filename
    # We loop from 0x00 to 0x20 (xrange is [a, b[), and check whether
    # the corresponding ASCII character (which we get through the chr(i)
    # function) is in the filename
    for c in range(0x00, 0x20):
        if chr(c) in filename:
            return False

    for c in (&#34;&lt;&#34;, &#34;&gt;&#34;, &#34;:&#34;, &#39;&#34;&#39;, &#34;/&#34;, &#34;\\&#34;, &#34;|&#34;, &#34;?&#34;, &#34;*&#34;):
        if c in filename:
            return False

    if filename.endswith((&#34; &#34;, &#34;.&#34;)):
        return False

    return True

    if j.data.platform.is_windows():
        return check_windows(filename)

    if j.data.platform.is_linux():
        return check_unix(filename)

    raise RuntimeError(&#34;Filename validation on given platform not supported&#34;)


def find(startDir, fileregex):
    &#34;&#34;&#34; Search for files or folders matching a given pattern.

    Args:
        startDir (str): [description]
        fileregex (str): [description]

    Returns:
        str: result
    &#34;&#34;&#34;

    result = []
    for root, dirs, files in os.walk(startDir, followlinks=True):
        for name in files:
            if fnmatch.fnmatch(name, fileregex):
                result.append(os.path.join(root, name))
    return result


def grep(fileregex, lineregex):
    &#34;&#34;&#34;Search for lines matching a given regex in all files matching a regex

   Args:
       fileregex (str):Files to search in.
       lineregex (str): Regex pattern to search for in each file.
   &#34;&#34;&#34;
    import glob
    import re
    import os

    for filename in glob.glob(fileregex):
        if os.path.isfile(filename):
            f = open(filename, &#34;r&#34;)
            for line in f:
                if re.match(lineregex, line):
                    print((&#34;%s: %s&#34; % (filename, line)))


def construct_dir_path_from_array(array):
    &#34;&#34;&#34; Create a path using os specific seperators from a list being passed with directoy.

    Args:
        array (str): list of dirs in the path.

    Returns:
        str: path
    &#34;&#34;&#34;
    path = &#34;&#34;
    for item in array:
        path = path + os.sep + item
    path = path + os.sep
    if j.data.platform.is_linux() or j.data.platform.is_osx():
        path = path.replace(&#34;//&#34;, &#34;/&#34;)
        path = path.replace(&#34;//&#34;, &#34;/&#34;)
    return path


def construct_file_path_from_array(array):
    &#34;&#34;&#34; Add file name  to dir path

    Args:
        array (str): list including dir path then file name

    Returns:
        str: path
    &#34;&#34;&#34;
    path = construct_dir_path_from_array(array)
    if path[-1] == &#34;/&#34;:
        path = path[0:-1]
    return path


def path_to_unicode(path):
    &#34;&#34;&#34; Convert Path to unicode.

    Args:
        path (str): the path to convert to unicode.

    Returns:
        str: unicode path
    &#34;&#34;&#34;

    from Jumpscale.core.Dirs import Dirs

    return Dirs.path_to_unicode(path)


def targz_compress(
    sourcepath,
    destinationpath,
    followlinks=False,
    destintar=&#34;&#34;,
    pathregexincludes=[&#34;.[a-zA-Z0-9]*&#34;],
    pathRegexExcludes=[],
    contentregexincludes=[],
    contentregexexcludes=[],
    depths=[],
    extrafiles=[],
):
    &#34;&#34;&#34; Compress targz.

    Args:
        sourcepath (str): Source directory.
        destinationpath (str): Destination filename.
        followlinks (bool):  do not tar the links, follow the link and add that file or content of directory to the tar. Defaults to False.
        destintar (str):  Defaults to &#34;&#34;.
        pathregexincludes (list): Defaults to [&#34;.[a-zA-Z0-9]*&#34;].
        pathRegexExcludes (list): [description]. Defaults to [].
        contentregexincludes (list): [description]. Defaults to [].
        contentregexexcludes (list): [description]. Defaults to [].
        depths (list): [description]. Defaults to [].
        extrafiles (list): Adds extra files to tar. Defaults to [].

    Raises:
        j.exceptions.RuntimeError: [description]
    &#34;&#34;&#34;
    import os.path
    import tarfile

    if not exists(get_dir_name(destinationpath)):
        create_dir(get_dir_name(destinationpath))
    t = tarfile.open(name=destinationpath, mode=&#34;w:gz&#34;)
    if not (
        followlinks
        or destintar != &#34;&#34;
        or pathregexincludes != [&#34;.*&#34;]
        or pathRegexExcludes != []
        or contentregexincludes != []
        or contentregexexcludes != []
        or depths != []
    ):
        t.add(sourcepath, &#34;/&#34;)
    else:

        def addToTar(params, path):
            tarfile = params[&#34;t&#34;]
            destintar = params[&#34;destintar&#34;]
            destpath = join_path(destintar, path_remove_dir_part(path, sourcepath))
            if is_link(path) and followlinks:
                path = read_link(path)

            # print &#34;fstar: add file %s to tar&#34; % path
            if not (j.data.platform.is_windows() and j.sals.windows.checkFileToIgnore(path)):
                if is_file(path) or is_link(path):
                    tarfile.add(path, destpath)
                else:
                    raise RuntimeError(&#34;Cannot add file %s to destpath&#34; % destpath)

        params = {}
        params[&#34;t&#34;] = t
        params[&#34;destintar&#34;] = destintar
        j.sals.fswalker.walk(
            root=sourcepath,
            callback=addToTar,
            arg=params,
            recursive=True,
            includeFolders=False,
            pathregexincludes=pathregexincludes,
            pathRegexExcludes=pathRegexExcludes,
            contentregexincludes=contentregexincludes,
            contentregexexcludes=contentregexexcludes,
            depths=depths,
            followlinks=False,
        )

        if extrafiles != []:
            for extrafile in extrafiles:
                source = extrafile[0]
                destpath = extrafile[1]
                t.add(source, join_path(destintar, destpath))
    t.close()


def gzip(sourcefile, destfile):
    &#34;&#34;&#34;Gzip source file into destination zip

    Args:
        sourcefile (str): path to file to be Gzipped.
        destfile (str): path to  destination Gzip file.
    &#34;&#34;&#34;
    import gzip

    f_in = open(sourcefile, &#34;rb&#34;)
    f_out = gzip.open(destfile, &#34;wb&#34;)
    f_out.writelines(f_in)
    f_out.close()
    f_in.close()


def gunzip(sourcefile, destFile):
    &#34;&#34;&#34;Gunzip gzip sourcefile into destination file

    Args:
        sourcefile (str): path to gzip file to be unzipped.
        destFile (str): path to destination folder to unzip folder.
    &#34;&#34;&#34;
    import gzip

    create_dir(get_dir_name(destFile))
    f_in = gzip.open(sourcefile, &#34;rb&#34;)
    f_out = open(destFile, &#34;wb&#34;)
    f_out.writelines(f_in)
    f_out.close()
    f_in.close()


def targz_uncompress(sourcefile, destinationdir, removedestinationdir=True):
    &#34;&#34;&#34; compress dirname recursive

    Args:
        sourcefile (str): file to uncompress.
        destinationdir (str): path of the destiniation directory.
        removedestinationdir (bool): [description]. Defaults to True.
    &#34;&#34;&#34;
    if removedestinationdir:
        remove(destinationdir)
    if not exists(destinationdir):
        create_dir(destinationdir)
    import tarfile

    # The tar of python does not create empty directories.. this causes
    # many problem while installing so we choose to use the linux tar here
    if j.data.platform.is_windows():
        tar = tarfile.open(sourcefile)
        tar.extractall(destinationdir)
        tar.close()
        # todo find better alternative for windows
    else:
        cmd = &#34;tar xzf &#39;%s&#39; -C &#39;%s&#39;&#34; % (sourcefile, destinationdir)
        j.sals.process.execute(cmd)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="jumpscale.sals.fs.fs.change_dir"><code class="name flex">
<span>def <span class="ident">change_dir</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Changes Current Directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory path to be changed to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>Current path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def change_dir(path):
    &#34;&#34;&#34; Changes Current Directory.

    Args:
        path (str): Directory path to be changed to.

    Returns:
        str: Current path
    &#34;&#34;&#34;
    os.chdir(path)
    current_path = os.getcwd()

    return current_path</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.change_file_names"><code class="name flex">
<span>def <span class="ident">change_file_names</span></span>(<span>toreplace, replacewidth, pathtosearchin, recursive=True, filter=None, minmtime=None, maxmtime=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Change File Names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>toreplace</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>replacewidth</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>pathtosearchin</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>recursive</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
<dt><strong><code>filter</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>minmtime</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>maxmtime</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>[description]. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def change_file_names(
    toreplace, replacewidth, pathtosearchin, recursive=True, filter=None, minmtime=None, maxmtime=None
):
    &#34;&#34;&#34; Change File Names.

Args:
    toreplace (str): [description]
    replacewidth (str): [description]
    pathtosearchin (str): [description]
    recursive (bool): [description]. Defaults to True.
    filter (NoneType): [description]. Defaults to None.
    minmtime (NoneType): [description]. Defaults to None.
    maxmtime (NoneType): [description]. Defaults to None.

Returns:
    [type]: [description]
&#34;&#34;&#34;

    if not toreplace:
        raise RuntimeError(&#34;Can&#39;t change file names, toreplace can&#39;t be empty&#34;)
    if not replacewidth:
        raise RuntimeError(&#34;Can&#39;t change file names, replacewidth can&#39;t be empty&#34;)
    paths = list_files_in_dir(pathtosearchin, recursive, filter, minmtime, maxmtime)
    for path in paths:
        dir_name = get_dir_name(path)
        file_name = get_base_name(path)
        new_file_name = file_name.replace(toreplace, replacewidth)
        if new_file_name != file_name:
            new_path = join_path(dir_name, new_file_name)
            rename_file(path, new_path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.check_dir_param"><code class="name flex">
<span>def <span class="ident">check_dir_param</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_dir_param(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Raises:
        j.exceptions.Value: [description]
        j.exceptions.RuntimeError: [description]
        j.exceptions.RuntimeError: [description]
        j.exceptions.Value: [description]
        j.exceptions.Value: [description]
        j.exceptions.Value: [description]
        Exception: [description]
        Exception: [description]
        j.exceptions.NotImplemented: [description]
        j.exceptions.RuntimeError: [description]

    Returns:
        [type]: [description]
&#34;&#34;&#34;

    if path.strip() == &#34;&#34;:
        raise RuntimeError(&#34;path parameter cannot be empty.&#34;)
    path = path_normalize(path)
    if path[-1] != &#34;/&#34;:
        path = path + &#34;/&#34;
    return path</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.check_unix"><code class="name flex">
<span>def <span class="ident">check_unix</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_unix(filename):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if len(filename) &gt; 255:
        return False

    if &#34;\0&#34; in filename or &#34;/&#34; in filename:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.check_windows"><code class="name flex">
<span>def <span class="ident">check_windows</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Check windows</p>
<h2 id="args">Args</h2>
<p>filename (str):</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_windows(filename):
    &#34;&#34;&#34; Check windows

Args:
    filename (str):

Raises:
    j.exceptions.NotImplemented: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;
    if len(filename) &gt; 255:
        return False

    if os.path.splitext(filename)[0] in (&#34;CON&#34;, &#34;PRN&#34;, &#34;AUX&#34;, &#34;CLOCK$&#34;, &#34;NUL&#34;):
        return False

    if os.path.splitext(filename)[0] in (&#34;COM%d&#34; % i for i in range(1, 9)):
        return False

    if os.path.splitext(filename)[0] in (&#34;LPT%d&#34; % i for i in range(1, 9)):
        return False

    # ASCII characters 0x00 - 0x1F are invalid in a Windows filename
    # We loop from 0x00 to 0x20 (xrange is [a, b[), and check whether
    # the corresponding ASCII character (which we get through the chr(i)
    # function) is in the filename
    for c in range(0x00, 0x20):
        if chr(c) in filename:
            return False

    for c in (&#34;&lt;&#34;, &#34;&gt;&#34;, &#34;:&#34;, &#39;&#34;&#39;, &#34;/&#34;, &#34;\\&#34;, &#34;|&#34;, &#34;?&#34;, &#34;*&#34;):
        if c in filename:
            return False

    if filename.endswith((&#34; &#34;, &#34;.&#34;)):
        return False

    return True

    if j.data.platform.is_windows():
        return check_windows(filename)

    if j.data.platform.is_linux():
        return check_unix(filename)

    raise RuntimeError(&#34;Filename validation on given platform not supported&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.chmod"><code class="name flex">
<span>def <span class="ident">chmod</span></span>(<span>path, permissions)</span>
</code></dt>
<dd>
<section class="desc"><p>Change the file mode bits of each given file according to mode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path of the file.</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def chmod(path, permissions):
    &#34;&#34;&#34; Change the file mode bits of each given file according to mode.

    Args:
        path (str): The path of the file.
        permissions (str): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if permissions &gt; 511 or permissions &lt; 0:
        raise RuntimeError(&#34;can&#39;t perform chmod, %s is not a valid mode&#34; % oct(permissions))

    os.chmod(path, permissions)
    for root, dirs, files in os.walk(path):
        for ddir in dirs:
            path = os.path.join(root, ddir)
            try:
                os.chmod(path, permissions)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise RuntimeError(&#34;%s&#34; % e)

        for file in files:
            path = os.path.join(root, file)
            try:
                os.chmod(path, permissions)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise RuntimeError(&#34;%s&#34; % e)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.chown"><code class="name flex">
<span>def <span class="ident">chown</span></span>(<span>path, user, group=None)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="args">Args</h2>
<dl>
<dt>path (str):</dt>
<dt>user (str):</dt>
<dt><strong><code>group</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>[description]. Defaults to None.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def chown(path, user, group=None):
    &#34;&#34;&#34;

    Args:
        path (str):
        user (str):
        group (NoneType): [description]. Defaults to None.
    &#34;&#34;&#34;
    from pwd import getpwnam
    from grp import getgrnam

    getpwnam(user)[2]
    uid = getpwnam(user).pw_uid
    if group is not None:
        gid = getgrnam(group).gr_gid
    else:
        gid = getpwnam(user).pw_gid
    os.chown(path, uid, gid)
    for root, dirs, files in os.walk(path):
        for ddir in dirs:
            path = os.path.join(root, ddir)
            try:
                os.chown(path, uid, gid)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise Exception(&#34;No such file or directory&#34;)
        for file in files:
            path = os.path.join(root, file)
            try:
                os.chown(path, uid, gid)
            except Exception as e:
                if str(e).find(&#34;No such file or directory&#34;) == -1:
                    raise Exception(&#34;No such file or directory&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.construct_dir_path_from_array"><code class="name flex">
<span>def <span class="ident">construct_dir_path_from_array</span></span>(<span>array)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a path using os specific seperators from a list being passed with directoy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>str</code></dt>
<dd>list of dirs in the path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def construct_dir_path_from_array(array):
    &#34;&#34;&#34; Create a path using os specific seperators from a list being passed with directoy.

    Args:
        array (str): list of dirs in the path.

    Returns:
        str: path
    &#34;&#34;&#34;
    path = &#34;&#34;
    for item in array:
        path = path + os.sep + item
    path = path + os.sep
    if j.data.platform.is_linux() or j.data.platform.is_osx():
        path = path.replace(&#34;//&#34;, &#34;/&#34;)
        path = path.replace(&#34;//&#34;, &#34;/&#34;)
    return path</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.construct_file_path_from_array"><code class="name flex">
<span>def <span class="ident">construct_file_path_from_array</span></span>(<span>array)</span>
</code></dt>
<dd>
<section class="desc"><p>Add file name
to dir path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>str</code></dt>
<dd>list including dir path then file name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def construct_file_path_from_array(array):
    &#34;&#34;&#34; Add file name  to dir path

    Args:
        array (str): list including dir path then file name

    Returns:
        str: path
    &#34;&#34;&#34;
    path = construct_dir_path_from_array(array)
    if path[-1] == &#34;/&#34;:
        path = path[0:-1]
    return path</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.copy_dir_tree"><code class="name flex">
<span>def <span class="ident">copy_dir_tree</span></span>(<span>src, dst, symlinks=False, ignore=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy Tree Directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>src</code></strong> :&ensp;<code>str</code></dt>
<dd>Source of tree directory.</dd>
<dt><strong><code>dst</code></strong> :&ensp;<code>str</code></dt>
<dd>destination of directory.</dd>
<dt><strong><code>symlinks</code></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to False.</dd>
<dt><strong><code>ignore</code></strong> :&ensp;<code>Nonetype</code></dt>
<dd>Defaults to None.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copy_dir_tree(src, dst, symlinks=False, ignore=None):
    &#34;&#34;&#34; Copy Tree Directory.

    Args:
        src (str): Source of tree directory.
        dst (str): destination of directory.
        symlinks (bool): Defaults to False.
        ignore (Nonetype): Defaults to None.
    &#34;&#34;&#34;
    for item in os.listdir(src):
        s = os.path.join(src, item)
        d = os.path.join(dst, item)
        if os.path.isdir(s):
            shutil.copytree(s, d, symlinks, ignore)
        else:
            shutil.copy2(s, d)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.copy_file"><code class="name flex">
<span>def <span class="ident">copy_file</span></span>(<span>filefrom, to, create_dir_ifneeded=False, overwritefile=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy File.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fileFrom</code></strong> :&ensp;<code>str</code></dt>
<dd>Source file path name.</dd>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>Destination file or folder path name.</dd>
<dt><strong><code>create_dir_ifneeded</code></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to False.</dd>
<dt><strong><code>overwritefile</code></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to True.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copy_file(filefrom, to, create_dir_ifneeded=False, overwritefile=True):
    &#34;&#34;&#34; Copy File.

    Args:
        fileFrom (str): Source file path name.
        to (str):  Destination file or folder path name.
        create_dir_ifneeded (bool): Defaults to False.
        overwritefile (bool):  Defaults to True.
        &#34;&#34;&#34;
    # Create target folder first, otherwise copy fails
    target_folder = os.path.dirname(to)
    if create_dir_ifneeded:
        create_dir(target_folder)
    if exists(to):
        if os.path.samefile(filefrom, to):
            raise RuntimeError(&#34;{src} and {dest} are the same file&#34;.format(src=filefrom, dest=to))
        if overwritefile is False:
            if os.path.samefile(to, target_folder):
                destfilename = os.path.join(to, os.path.basename(filefrom))
                if exists(destfilename):
                    return
            else:
                return
        elif is_file(to):
            # overwriting some open  files is frustrating and may not work
            # due to locking [delete/copy is a better strategy]
            remove(to)
    shutil.copy(filefrom, to)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.create_dir"><code class="name flex">
<span>def <span class="ident">create_dir</span></span>(<span>newdir, unlink=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Create New Directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>newdir</code></strong> :&ensp;<code>str</code></dt>
<dd>Directory path/name.</dd>
<dt><strong><a title="jumpscale.sals.fs.fs.unlink" href="#jumpscale.sals.fs.fs.unlink"><code>unlink()</code></a></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to False.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_dir(newdir, unlink=False):
    &#34;&#34;&#34; Create New Directory.

    Args:
        newdir (str): Directory path/name.
        unlink (bool): Defaults to False.

    &#34;&#34;&#34;
    if newdir.find(&#34;file://&#34;) != -1:
        raise RuntimeError(&#34;Cannot use file notation here&#34;)

    if exists(newdir):
        if is_link(newdir) and unlink:
            unlink(newdir)
    else:
        head, tail = os.path.split(newdir)
        if head and (not exists(head) or not is_dir(head)):
            create_dir(head, unlink=False)
        if tail:
            os.mkdir(newdir)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.create_empty_file"><code class="name flex">
<span>def <span class="ident">create_empty_file</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Create An Empty File.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>file path name to be created</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_empty_file(filename):
    &#34;&#34;&#34; Create An Empty File.

  Args:
      filename (str): file path name to be created
  &#34;&#34;&#34;
    open(filename, &#34;w&#34;).close()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>path, followlinks=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Check if the specified path exists.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>followlinks</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exists(path, followlinks=True):
    &#34;&#34;&#34; Check if the specified path exists.

    Args:
        path (str): [description]
        followlinks (bool): [description]. Defaults to True.

    Raises:
        j.exceptions.Value: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if path is None:
        raise RuntimeError(&#34;Path is not passed in system.fs.exists&#34;)

    found = False
    try:
        st = os.lstat(path)
        found = True
    except (OSError, AttributeError):
        pass
    if found and followlinks and stat.S_ISLNK(st.st_mode):

        relativelink = read_link(path)
        newpath = join_path(get_parent(path), relativelink)
        return exists(newpath)
    if found:
        return True

    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.file_size"><code class="name flex">
<span>def <span class="ident">file_size</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the size of the file in bytes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the file that you want to know the size of it.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>int</code></strong> :&ensp;<code>getsize</code> <code>filename</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def file_size(filename):
    &#34;&#34;&#34; Get the size of the file in bytes.

    Args:
        filename (str): the name of the file that you want to know the size of it.

    Raises:
        j.exceptions.Value: [description]
        Exception: [description]
        Exception: [description]
        j.exceptions.NotImplemented: [description]
        j.exceptions.RuntimeError: [description]

    Returns:
        int : getsize filename
    &#34;&#34;&#34;
    return os.path.getsize(filename)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>startDir, fileregex)</span>
</code></dt>
<dd>
<section class="desc"><p>Search for files or folders matching a given pattern.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>startDir</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>fileregex</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>result</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def find(startDir, fileregex):
    &#34;&#34;&#34; Search for files or folders matching a given pattern.

    Args:
        startDir (str): [description]
        fileregex (str): [description]

    Returns:
        str: result
    &#34;&#34;&#34;

    result = []
    for root, dirs, files in os.walk(startDir, followlinks=True):
        for name in files:
            if fnmatch.fnmatch(name, fileregex):
                result.append(os.path.join(root, name))
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_base_name"><code class="name flex">
<span>def <span class="ident">get_base_name</span></span>(<span>path, remove_extension=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the base name of pathname path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the base name</dd>
<dt><strong><code>remove_extension</code></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>name</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_base_name(path, remove_extension=False):
    &#34;&#34;&#34; Return the base name of pathname path.

    Args:
        path (str): the path of the base name
        remove_extension (bool): Defaults to False.

    Returns:
        str: name
    &#34;&#34;&#34;
    name = os.path.basename(path.rstrip(os.path.sep))
    if remove_extension:
        if &#34;.&#34; in name:
            name = &#34;.&#34;.join(name.split(&#34;.&#34;)[:-1])
    return name
    basename = get_base_name</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_dir_name"><code class="name flex">
<span>def <span class="ident">get_dir_name</span></span>(<span>path, lastonly=False, levelsup=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a directory name from pathname path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to find a directory.</dd>
<dt><strong><code>lastonly</code></strong> :&ensp;<code>bool</code></dt>
<dd>Means only the last part of the path which is a dir (overrides levelsup to 0).Defaults to False.</dd>
<dt><strong><code>levelsup</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>Means return the parent dir levelsup levels up. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>dname + os.sep</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_dir_name(path, lastonly=False, levelsup=None):
    &#34;&#34;&#34; Return a directory name from pathname path.

    Args:
        path (str): The path to find a directory.
        lastonly (bool): Means only the last part of the path which is a dir (overrides levelsup to 0).Defaults to False.
        levelsup (NoneType): Means return the parent dir levelsup levels up. Defaults to None.

    Returns:
        str: dname + os.sep
    &#34;&#34;&#34;

    dname = os.path.dirname(path)
    dname = dname.replace(&#34;/&#34;, os.sep)
    dname = dname.replace(&#34;//&#34;, os.sep)
    dname = dname.replace(&#34;\\&#34;, os.sep)
    if lastonly:
        dname = dname.split(os.sep)[-1]
        return dname
    if levelsup is not None:
        parts = dname.split(os.sep)
        if len(parts) - levelsup &gt; 0:
            return parts[len(parts) - levelsup - 1]
        else:
            raise RuntimeError(&#34;Cannot find part of dir %s levels up, path %s is not long enough&#34; % (levelsup, path))
    return dname + os.sep if dname else dname</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_file_extension"><code class="name flex">
<span>def <span class="ident">get_file_extension</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the extension of the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of file extension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>file extension.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_file_extension(path):
    &#34;&#34;&#34; Returns the extension of the file.

    Args:
        path (str): the path of file extension.

    Returns:
        str: file extension.
    &#34;&#34;&#34;
    ext = os.path.splitext(path)[1]
    return ext.strip(&#34;.&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_folder_md5sum"><code class="name flex">
<span>def <span class="ident">get_folder_md5sum</span></span>(<span>folder)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>md5sum files</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_folder_md5sum(folder):
    &#34;&#34;&#34;[summary]

    Args:
        folder ([type]): [description]

    Returns:
        str: md5sum files
    &#34;&#34;&#34;
    files = sorted(os.walk(folder))
    return md5sum(files)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_parent"><code class="name flex">
<span>def <span class="ident">get_parent</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the parent of the path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>source path to get the parent.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>the parent of the path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_parent(path):
    &#34;&#34;&#34;Returns the parent of the path.

    Args:
        path (str): source path to get the parent.

    Returns:
        str: the parent of the path
    &#34;&#34;&#34;
    parts = path.split(os.sep)
    if parts[-1] == &#34;&#34;:
        parts = parts[:-1]
    parts = parts[:-1]
    if parts == [&#34;&#34;]:
        return os.sep
    return os.sep.join(parts)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_parent_with_dir_name"><code class="name flex">
<span>def <span class="ident">get_parent_with_dir_name</span></span>(<span>path='', dirname='.git', die=False)</span>
</code></dt>
<dd>
<section class="desc"><p>looks for parent which has dirname in the parent directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Defaults to "".</dd>
<dt><strong><code>dirname</code></strong> :&ensp;<code>str</code></dt>
<dd>Defaults to ".git".</dd>
<dt><strong><code>die</code></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to False.</dd>
<dt>Returns:</dt>
<dt><strong><code>str</code></strong> :&ensp;<code>the</code> <code>path</code> <code>which</code> <code>has</code> <code>the</code> <code>dirname</code> or <code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_parent_with_dir_name(path=&#34;&#34;, dirname=&#34;.git&#34;, die=False):
    &#34;&#34;&#34; looks for parent which has dirname in the parent directory.

    Args:
        path (str): Defaults to &#34;&#34;.
        dirname (str): Defaults to &#34;.git&#34;.
        die (bool): Defaults to False.

    Returns:
    str: the path which has the dirname or None
    &#34;&#34;&#34;

    if path == &#34;&#34;:
        path = getcwd()

    # first check if there is no .jsconfig in parent dirs
    curdir = copy.copy(path)
    while curdir.strip() != &#34;&#34;:
        if exists(&#34;%s/%s&#34; % (curdir, dirname)):
            return curdir
        # look for parent
        curdir = get_parent(curdir)
    if die:
        raise Exception(&#34;Could not find %s dir as parent of:&#39;%s&#39;&#34; % (dirname, path))
    else:
        return None</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_path_of_running_function"><code class="name flex">
<span>def <span class="ident">get_path_of_running_function</span></span>(<span>function)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Path of Running Function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>getfile</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_path_of_running_function(function):
    &#34;&#34;&#34; Get Path of Running Function.

    Args:
        function (str): [description]

    Returns:
        str: getfile
    &#34;&#34;&#34;
    return inspect.getfile(function)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_tmp_dir_path"><code class="name flex">
<span>def <span class="ident">get_tmp_dir_path</span></span>(<span>name='', create=True)</span>
</code></dt>
<dd>
<section class="desc"><p>create a tmp dir name and makes sure the dir exists</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]. Defaults to "".</dd>
<dt><strong><code>create</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>tmpdir</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_tmp_dir_path(name=&#34;&#34;, create=True):
    &#34;&#34;&#34;  create a tmp dir name and makes sure the dir exists

  Args:
      name (str): [description]. Defaults to &#34;&#34;.
      create (bool): [description]. Defaults to True.

  Returns:
      bool: tmpdir
  &#34;&#34;&#34;
    if name:
        tmpdir = join_path(j.dirs.TMPDIR, name)
    else:
        tmpdir = join_path(j.dirs.TMPDIR, j.data.idgenerator.generateXCharID(10))
    if create is True:
        create_dir(tmpdir)
    return tmpdir</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.get_tmp_file_path"><code class="name flex">
<span>def <span class="ident">get_tmp_file_path</span></span>(<span>cygwin=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate a temp file path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cygwin</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_tmp_file_path(cygwin=False):
    &#34;&#34;&#34;Generate a temp file path

    Args:
        cygwin (bool): [description]. Defaults to False.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    tmpdir = j.dirs.TMPDIR + &#34;/jumpscale/&#34;
    j.sals.fs.create_dir(tmpdir)
    fd, path = tempfile.mkstemp(dir=tmpdir)
    try:
        real_fd = os.fdopen(fd)
        real_fd.close()
    except (IOError, OSError):
        pass
    if cygwin:
        path = path.replace(&#34;\\&#34;, &#34;/&#34;)
        path = path.replace(&#34;//&#34;, &#34;/&#34;)
    return path</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.getcwd"><code class="name flex">
<span>def <span class="ident">getcwd</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Get Current working Directory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>current working directory path.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def getcwd():
    &#34;&#34;&#34; Get Current working Directory.

    Returns:
        str: current working directory path.
    &#34;&#34;&#34;
    return os.getcwd()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.grep"><code class="name flex">
<span>def <span class="ident">grep</span></span>(<span>fileregex, lineregex)</span>
</code></dt>
<dd>
<section class="desc"><p>Search for lines matching a given regex in all files matching a regex</p>
<h2 id="args">Args</h2>
<dl>
<dt>fileregex (str):Files to search in.</dt>
<dt><strong><code>lineregex</code></strong> :&ensp;<code>str</code></dt>
<dd>Regex pattern to search for in each file.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def grep(fileregex, lineregex):
    &#34;&#34;&#34;Search for lines matching a given regex in all files matching a regex

   Args:
       fileregex (str):Files to search in.
       lineregex (str): Regex pattern to search for in each file.
   &#34;&#34;&#34;
    import glob
    import re
    import os

    for filename in glob.glob(fileregex):
        if os.path.isfile(filename):
            f = open(filename, &#34;r&#34;)
            for line in f:
                if re.match(lineregex, line):
                    print((&#34;%s: %s&#34; % (filename, line)))</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.gunzip"><code class="name flex">
<span>def <span class="ident">gunzip</span></span>(<span>sourcefile, destFile)</span>
</code></dt>
<dd>
<section class="desc"><p>Gunzip gzip sourcefile into destination file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sourcefile</code></strong> :&ensp;<code>str</code></dt>
<dd>path to gzip file to be unzipped.</dd>
<dt><strong><code>destFile</code></strong> :&ensp;<code>str</code></dt>
<dd>path to destination folder to unzip folder.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gunzip(sourcefile, destFile):
    &#34;&#34;&#34;Gunzip gzip sourcefile into destination file

    Args:
        sourcefile (str): path to gzip file to be unzipped.
        destFile (str): path to destination folder to unzip folder.
    &#34;&#34;&#34;
    import gzip

    create_dir(get_dir_name(destFile))
    f_in = gzip.open(sourcefile, &#34;rb&#34;)
    f_out = open(destFile, &#34;wb&#34;)
    f_out.writelines(f_in)
    f_out.close()
    f_in.close()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.gzip"><code class="name flex">
<span>def <span class="ident">gzip</span></span>(<span>sourcefile, destfile)</span>
</code></dt>
<dd>
<section class="desc"><p>Gzip source file into destination zip</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sourcefile</code></strong> :&ensp;<code>str</code></dt>
<dd>path to file to be Gzipped.</dd>
<dt><strong><code>destfile</code></strong> :&ensp;<code>str</code></dt>
<dd>path to
destination Gzip file.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gzip(sourcefile, destfile):
    &#34;&#34;&#34;Gzip source file into destination zip

    Args:
        sourcefile (str): path to file to be Gzipped.
        destfile (str): path to  destination Gzip file.
    &#34;&#34;&#34;
    import gzip

    f_in = open(sourcefile, &#34;rb&#34;)
    f_out = gzip.open(destfile, &#34;wb&#34;)
    f_out.writelines(f_in)
    f_out.close()
    f_in.close()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.hardlink_file"><code class="name flex">
<span>def <span class="ident">hardlink_file</span></span>(<span>source, destin)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>destin</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hardlink_file(source, destin):
    &#34;&#34;&#34;[summary]

  Args:
      source ([type]): [description]
      destin ([type]): [description]

  Raises:
      j.exceptions.RuntimeError: [description]

  Returns:
      [type]: [description]
  &#34;&#34;&#34;

    if j.data.platform.is_linux() or j.data.platform.is_osx():
        return os.link(source, destin)
    else:
        raise RuntimeError(&#34;Cannot create a hard link on windows&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_absolute"><code class="name flex">
<span>def <span class="ident">is_absolute</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_absolute(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return os.path.isabs(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_asxii_file"><code class="name flex">
<span>def <span class="ident">is_asxii_file</span></span>(<span>filename, checksize=4096)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>checksize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 4096.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_asxii_file(filename, checksize=4096):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]
        checksize (int, optional): [description]. Defaults to 4096.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    # TODO: let&#39;s talk about checksize feature.
    try:
        with open(filename, encoding=&#34;ascii&#34;) as f:
            f.read()
            return True
    except UnicodeDecodeError:
        return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_binary_file"><code class="name flex">
<span>def <span class="ident">is_binary_file</span></span>(<span>filename, checksize=4096)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>checksize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 4096.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_binary_file(filename, checksize=4096):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]
        checksize (int, optional): [description]. Defaults to 4096.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return not is_asxii_file(filename, checksize)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_dir"><code class="name flex">
<span>def <span class="ident">is_dir</span></span>(<span>path, followsoftlink=False)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>followsoftlink</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_dir(path, followsoftlink=False):
    &#34;&#34;&#34;[summary]

 Args:
     path ([type]): [description]
     followsoftlink (bool, optional): [description]. Defaults to False.

 Returns:
     [type]: [description]
 &#34;&#34;&#34;

    if is_link(path):
        if not followsoftlink:
            return False
        path = read_link(path)
    return os.path.isdir(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_empty_dir"><code class="name flex">
<span>def <span class="ident">is_empty_dir</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_empty_dir(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if _list_in_dir(path) == []:

        return True

    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_executable"><code class="name flex">
<span>def <span class="ident">is_executable</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_executable(path):
    &#34;&#34;&#34;[summary]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    statobj = stat_path(path, follow_symlinks=False)
    return not (stat.S_IXUSR &amp; statobj.st_mode == 0)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_file"><code class="name flex">
<span>def <span class="ident">is_file</span></span>(<span>path, followsoftlink=True)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>followsoftlink</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_file(path, followsoftlink=True):
    &#34;&#34;&#34;[summary]

 Args:
     path ([type]): [description]
     followsoftlink (bool, optional): [description]. Defaults to True.

 Returns:
     [type]: [description]
 &#34;&#34;&#34;

    if not followsoftlink and is_link(path):

        return True

    if os.path.isfile(path):

        return True

    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_link"><code class="name flex">
<span>def <span class="ident">is_link</span></span>(<span>path, checkjunction=False, check_valid=False)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>checkjunction</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
<dt><strong><code>check_valid</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_link(path, checkjunction=False, check_valid=False):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]
        checkjunction (bool, optional): [description]. Defaults to False.
        check_valid (bool, optional): [description]. Defaults to False.

    Raises:
        j.exceptions.RuntimeError: [description]
        j.exceptions.RuntimeError: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if path[-1] == os.sep:
        path = path[:-1]

    if checkjunction and j.data.platform.is_windows():
        cmd = &#34;junction %s&#34; % path
        try:
            result = []
            # result = j.sals.process.execute(cmd)
            pass
        except Exception as e:
            raise RuntimeError(&#34;Could not execute junction cmd, is junction installed? Cmd was %s.&#34; % cmd)
        if result[0] != 0:
            raise RuntimeError(&#34;Could not execute junction cmd, is junction installed? Cmd was %s.&#34; % cmd)
        if result[1].lower().find(&#34;substitute name&#34;) != -1:
            return True
        else:
            return False

    if os.path.islink(path):
        if check_valid:
            j.shell()
        return True

    return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_link_and_broken"><code class="name flex">
<span>def <span class="ident">is_link_and_broken</span></span>(<span>path, remove_if_broken=True)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>remove_if_broken</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_link_and_broken(path, remove_if_broken=True):
    &#34;&#34;&#34;[summary]

Args:
    path ([type]): [description]
    remove_if_broken (bool, optional): [description]. Defaults to True.

Raises:
    j.exceptions.RuntimeError: [description]
    j.exceptions.RuntimeError: [description]
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    Exception: [description]
    Exception: [description]
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;

    if os.path.islink(path):
        rpath = read_link(path)
        if not exists(rpath):
            if remove_if_broken:
                remove(path)
            return True
    return False

    &#34;&#34;&#34;Check if the specified path is a link
    @param path: string
    @rtype: boolean (True if the specified path is a link)

    @PARAM check_valid if True, will remove link if the dest is not there and return False
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.is_mount"><code class="name flex">
<span>def <span class="ident">is_mount</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def is_mount(path):
    &#34;&#34;&#34;[summary]

    Args:
        path ([type]): [description]

    Raises:
        j.exceptions.Value: [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    if path is None:
        raise RuntimeError(&#34;Path is passed null in system.fs.isMount&#34;)
    return os.path.ismount(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.join_path"><code class="name flex">
<span>def <span class="ident">join_path</span></span>(<span>*args)</span>
</code></dt>
<dd>
<section class="desc"><p>Join one or more path components.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>Join two or more pathname components.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def join_path(*args):
    &#34;&#34;&#34; Join one or more path components.

    Returns:
        str: Join two or more pathname components.
    &#34;&#34;&#34;
    args = [str(x) for x in args]

    if args is None:
        raise RuntimeError(&#34;Not enough parameters %s&#34; % (str(args)))
    if os.sys.platform.startswith(&#34;win&#34;):
        args2 = []
        for item in args:
            item = item.replace(&#34;/&#34;, &#34;\\&#34;)
            while len(item) &gt; 0 and item[0] == &#34;\\&#34;:
                item = item[1:]
            args2.append(item)
        args = args2
    return os.path.join(*args)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.list_dirs_in_dir"><code class="name flex">
<span>def <span class="ident">list_dirs_in_dir</span></span>(<span>path, recursive=False, dirnameonly=False, finddirectorysymlinks=True, followsymlinks=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves list of directories found in the specified directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>represents directory path to search in.</dd>
<dt><strong><code>recursive</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to False.</dd>
<dt><strong><code>dirnameonly</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to False.</dd>
<dt><strong><code>finddirectorysymlinks</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
<dt><strong><code>followsymlinks</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_dirs_in_dir(path, recursive=False, dirnameonly=False, finddirectorysymlinks=True, followsymlinks=True):
    &#34;&#34;&#34; Retrieves list of directories found in the specified directory.

    Args:
        path (str): represents directory path to search in.
        recursive (bool): [description]. Defaults to False.
        dirnameonly (bool): [description]. Defaults to False.
        finddirectorysymlinks (bool): [description]. Defaults to True.
        followsymlinks (bool): [description]. Defaults to True.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    items = _list_in_dir(path)
    filesreturn = []
    for item in items:
        fullpath = os.path.join(path, item)
        if item.startswith(&#34;Icon&#34;):
            continue
        if is_dir(fullpath, finddirectorysymlinks):
            if dirnameonly:
                filesreturn.append(item)
            else:
                filesreturn.append(fullpath)
        if recursive and is_dir(fullpath, followsymlinks):
            if is_link(fullpath):
                fullpath = read_link(fullpath)
            filesreturn.extend(
                list_dirs_in_dir(
                    fullpath,
                    recursive=recursive,
                    dirnameonly=dirnameonly,
                    finddirectorysymlinks=finddirectorysymlinks,
                    followsymlinks=followsymlinks,
                )
            )
    return filesreturn</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.list_files_and_dirs_in_dir"><code class="name flex">
<span>def <span class="ident">list_files_and_dirs_in_dir</span></span>(<span>path, recursive=True, filter=None, minmtime=None, maxmtime=None, depth=None, type='fd', followsymlinks=False, listsymlinks=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves list of files found in the specified directory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>Return Files.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_files_and_dirs_in_dir(
    path,
    recursive=True,
    filter=None,
    minmtime=None,
    maxmtime=None,
    depth=None,
    type=&#34;fd&#34;,
    followsymlinks=False,
    listsymlinks=False,
):

    &#34;&#34;&#34;Retrieves list of files found in the specified directory.

   Returns:
       str: Return Files.
    &#34;&#34;&#34;
    if depth is not None:
        depth = int(depth)

    if depth == 0:
        depth = None
    # if depth is not None:
    #     depth+=1
    filesreturn, _ = _list_all_in_dir(
        path,
        recursive,
        filter,
        minmtime,
        maxmtime,
        depth,
        type=type,
        followsymlinks=followsymlinks,
        listsymlinks=listsymlinks,
    )
    return filesreturn</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.list_files_in_dir"><code class="name flex">
<span>def <span class="ident">list_files_in_dir</span></span>(<span>path, recursive=False, filter=None, minmtime=None, maxmtime=None, depth=None, case_sensitivity='os', exclude=[], followsymlinks=False, listsymlinks=False)</span>
</code></dt>
<dd>
<section class="desc"><p>List of files in directory.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>list of files</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_files_in_dir(
    path,
    recursive=False,
    filter=None,
    minmtime=None,
    maxmtime=None,
    depth=None,
    case_sensitivity=&#34;os&#34;,
    exclude=[],
    followsymlinks=False,
    listsymlinks=False,
):
    &#34;&#34;&#34; List of files in directory.

    Returns:
      str: list of files
    &#34;&#34;&#34;
    if depth is not None:
        depth = int(depth)

    if depth == 0:
        depth = None
    # if depth is not None:
    #     depth+=1
    filesreturn, depth = _list_all_in_dir(
        path,
        recursive,
        filter,
        minmtime,
        maxmtime,
        depth,
        type=&#34;f&#34;,
        case_sensitivity=case_sensitivity,
        exclude=exclude,
        followsymlinks=followsymlinks,
        listsymlinks=listsymlinks,
    )
    return filesreturn</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.list_py_scripts_in_dir"><code class="name flex">
<span>def <span class="ident">list_py_scripts_in_dir</span></span>(<span>path, recursive=True, filter='*.py')</span>
</code></dt>
<dd>
<section class="desc"><p>Retrieves list of python scripts (with extension .py) in the specified directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Represents the directory path.</dd>
<dt><strong><code>recursive</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
<dt><strong><code>filter</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]. Defaults to "*.py".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>result</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_py_scripts_in_dir(path, recursive=True, filter=&#34;*.py&#34;):
    &#34;&#34;&#34; Retrieves list of python scripts (with extension .py) in the specified directory

    Args:
        path (str): Represents the directory path.
        recursive (bool): [description]. Defaults to True.
        filter (str): [description]. Defaults to &#34;*.py&#34;.

    Returns:
        str: result
    &#34;&#34;&#34;
    result = []
    for file in list_files_in_dir(path, recursive=recursive, filter=filter):
        if file.endswith(&#34;.py&#34;):
            # filename = file.split(os.sep)[-1]
            # scriptname = filename.rsplit(&#34;.&#34;, 1)[0]
            result.append(file)
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.md5sum"><code class="name flex">
<span>def <span class="ident">md5sum</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def md5sum(filename):
    &#34;&#34;&#34;[summary]

Args:
    filename ([type]): [description]

Raises:
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;

    if not isinstance(filename, list):
        filename = [filename]
    digest = hashlib.md5()
    for filepath in filename:
        with open(filepath, &#34;rb&#34;) as fh:
            while True:
                buf = fh.read(4096)
                if buf == b&#34;&#34;:
                    break
                digest.update(buf)
    return digest.hexdigest()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.move_dir"><code class="name flex">
<span>def <span class="ident">move_dir</span></span>(<span>source, destin)</span>
</code></dt>
<dd>
<section class="desc"><p>Move Directory from source to destination.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>Source path where the directory should be removed from</dd>
<dt><strong><code>destin</code></strong> :&ensp;<code>str</code></dt>
<dd>Destination path where the directory should be moved into</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def move_dir(source, destin):
    &#34;&#34;&#34; Move Directory from source to destination.

    Args:
        source (str): Source path where the directory should be removed from
        destin (str): Destination path where the directory should be moved into
    &#34;&#34;&#34;
    _move(source, destin)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.move_file"><code class="name flex">
<span>def <span class="ident">move_file</span></span>(<span>source, destin)</span>
</code></dt>
<dd>
<section class="desc"><p>Move a
File from source path to destination path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code></dt>
<dd>Source File Path.</dd>
<dt><strong><code>destin</code></strong> :&ensp;<code>str</code></dt>
<dd>Destination Path The File Should Be Moved to.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def move_file(source, destin):
    &#34;&#34;&#34; Move a  File from source path to destination path.

    Args:
        source (str): Source File Path.
        destin (str): Destination Path The File Should Be Moved to.
    &#34;&#34;&#34;
    _move(source, destin)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.path_clean"><code class="name flex">
<span>def <span class="ident">path_clean</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Clean path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>source of the path of dir</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>normcase path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def path_clean(path):
    &#34;&#34;&#34; Clean path.

    Args:
        path (str): source of the path of dir

    Returns:
        str: normcase path
    &#34;&#34;&#34;

    return path.replace(&#34;\\&#34;, os.sep).replace(&#34;/&#34;, os.sep).lower()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.path_dir_clean"><code class="name flex">
<span>def <span class="ident">path_dir_clean</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Clean Path Directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>source of the path of dir</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>normcase path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def path_dir_clean(path):
    &#34;&#34;&#34; Clean Path Directory.

    Args:
        path (str): source of the path of dir

    Returns:
        str: normcase path
    &#34;&#34;&#34;
    return os.path.normpath(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.path_normalize"><code class="name flex">
<span>def <span class="ident">path_normalize</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Normalize Path</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to be normalize</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>Return the absolute version of a path.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def path_normalize(path):
    &#34;&#34;&#34; Normalize Path

    Args:
        path (str): The path to be normalize

    Returns:
        str: Return the absolute version of a path.
    &#34;&#34;&#34;
    return os.path.normpath(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.path_remove_dir_part"><code class="name flex">
<span>def <span class="ident">path_remove_dir_part</span></span>(<span>path, toremove, remove_trailing_slash=False)</span>
</code></dt>
<dd>
<section class="desc"><p>goal remove dirparts of a dirpath e,g, a basepath which is not needed
will look for part to remove in full path but only full dirs</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def path_remove_dir_part(path, toremove, remove_trailing_slash=False):
    &#34;&#34;&#34;
    goal remove dirparts of a dirpath e,g, a basepath which is not needed
    will look for part to remove in full path but only full dirs
    &#34;&#34;&#34;
    path = path_normalize(path)
    toremove = path_normalize(toremove)

    if path_clean(toremove) == path_clean(path):
        return &#34;&#34;
    path = path_clean(path)
    path = path.replace(path_dir_clean(toremove), &#34;&#34;)
    if remove_trailing_slash:
        if len(path) &gt; 0 and path[0] == os.sep:
            path = path[1:]
    path = path_clean(path)
    path = path_normalize(path)
    return path</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.path_to_unicode"><code class="name flex">
<span>def <span class="ident">path_to_unicode</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert Path to unicode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to convert to unicode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>unicode path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def path_to_unicode(path):
    &#34;&#34;&#34; Convert Path to unicode.

    Args:
        path (str): the path to convert to unicode.

    Returns:
        str: unicode path
    &#34;&#34;&#34;

    from Jumpscale.core.Dirs import Dirs

    return Dirs.path_to_unicode(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.process_path_for_double_dots"><code class="name flex">
<span>def <span class="ident">process_path_for_double_dots</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>double dots process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path for double dots process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code>:</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def process_path_for_double_dots(path):
    &#34;&#34;&#34; double dots process.

    Args:
        path (str): the path for double dots process.

    Returns:
        str:
    &#34;&#34;&#34;

    # print &#34;process_path_for_double_dots:%s&#34;%path
    path = path_clean(path)
    path = path.replace(&#34;\\&#34;, &#34;/&#34;)
    result = []
    for item in path.split(&#34;/&#34;):
        if item == &#34;..&#34;:
            if result == []:
                raise RuntimeError(&#34;Cannot process_path_for_double_dots for paths with only ..&#34;)
            else:
                result.pop()
        else:
            result.append(item)
    return &#34;/&#34;.join(result)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.read_link"><code class="name flex">
<span>def <span class="ident">read_link</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Read links</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>res</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_link(path):
    &#34;&#34;&#34; Read links

    Args:
        path (str): [description]

    Returns:
        str: res
    &#34;&#34;&#34;

    while path[-1] == &#34;/&#34; or path[-1] == &#34;\\&#34;:
        path = path[:-1]

    if j.data.platform.is_linux() or j.data.platform.is_osx():
        res = os.readlink(path)
    elif j.data.platform.is_windows():
        raise RuntimeError(&#34;Cannot read_link on windows&#34;)
    else:
        raise RuntimeError(&#34;cant read link, dont understand platform&#34;)

    if res.startswith(&#34;..&#34;):
        srcDir = get_dir_name(path)
        res = path_normalize(&#34;%s%s&#34; % (srcDir, res))
    elif get_base_name(res) == res:
        res = join_path(get_parent(path), res)
    return res</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.read_object_from_file"><code class="name flex">
<span>def <span class="ident">read_object_from_file</span></span>(<span>filelocation)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filelocation</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_object_from_file(filelocation):
    &#34;&#34;&#34;[summary]

Args:
    filelocation ([type]): [description]

Raises:
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;

    file = os.open(filelocation)
    contents = file.readfile()
    file.close()
    return pickle.loads(contents)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.readfile"><code class="name flex">
<span>def <span class="ident">readfile</span></span>(<span>filename, binary=False, encoding='utf-8')</span>
</code></dt>
<dd>
<section class="desc"><p>Read a file and get contents of that file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename to open for reading</dd>
<dt><strong><code>binary</code></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to False.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>Defaults to "utf-8".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>data</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def readfile(filename, binary=False, encoding=&#34;utf-8&#34;):
    &#34;&#34;&#34; Read a file and get contents of that file.

    Args:
        filename (str): filename to open for reading
        binary (bool):  Defaults to False.
        encoding (str):  Defaults to &#34;utf-8&#34;.

    Returns:
        str: data
    &#34;&#34;&#34;

    if binary:
        with open(filename, mode=&#34;rb&#34;) as fp:
            data = fp.read()
    else:
        with open(filename, encoding=encoding) as fp:
            data = fp.read()
    return data</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a File.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>File path required to be removed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>delete path</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove(path):
    &#34;&#34;&#34; Remove a File.

    Args:
        path (str): File path required to be removed.

    Returns:
        str: delete path
    &#34;&#34;&#34;
    return os.remove(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.remove_irrelevant_files"><code class="name flex">
<span>def <span class="ident">remove_irrelevant_files</span></span>(<span>path, followsymlinks=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Will remove files having extensions: pyc, bak.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to search in.</dd>
<dt><strong><code>followsymlinks</code></strong> :&ensp;<code>bool</code></dt>
<dd>Defaults to True.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_irrelevant_files(path, followsymlinks=True):
    &#34;&#34;&#34; Will remove files having extensions: pyc, bak.

    Args:
        path (str): path to search in.
        followsymlinks (bool): Defaults to True.
    &#34;&#34;&#34;
    ext = [&#34;pyc&#34;, &#34;bak&#34;]
    for path in list_files_in_dir(path, recursive=True, followsymlinks=followsymlinks):
        if get_file_extension(path) in ext:
            remove(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.remove_links"><code class="name flex">
<span>def <span class="ident">remove_links</span></span>(<span>path)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove all links.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path of the link</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_links(path):
    &#34;&#34;&#34; Remove all links.

    Args:
        path (str): the path of the link
    &#34;&#34;&#34;
    items = _list_all_in_dir(path=path, recursive=True, followsymlinks=False, listsymlinks=True)
    items = [item for item in items[0] if is_link(item)]
    for item in items:
        unlink(item)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.rename_dir"><code class="name flex">
<span>def <span class="ident">rename_dir</span></span>(<span>dirname, newname, overwrite=False)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirname</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>newname</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rename_dir(dirname, newname, overwrite=False):
    &#34;&#34;&#34;[summary]

Args:
    dirname ([type]): [description]
    newname ([type]): [description]
    overwrite (bool, optional): [description]. Defaults to False.

Raises:
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    Exception: [description]
    Exception: [description]
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;
    if dirname == newname:
        return
    if overwrite and exists(newname):
        if is_dir(newname):
            remove(newname)
        else:
            remove(newname)
    os.rename(dirname, newname)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.rename_file"><code class="name flex">
<span>def <span class="ident">rename_file</span></span>(<span>filepath, new_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Rename File.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of the file.</dd>
<dt><strong><code>new_name</code></strong> :&ensp;<code>str</code></dt>
<dd>New name of the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>str</code></strong></dt>
<dd>File path + New name</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rename_file(filepath, new_name):
    &#34;&#34;&#34; Rename File.

    Args:
        filepath (str): Path of the file.
        new_name (str): New name of the file.

    Returns:
        str: File path + New name
    &#34;&#34;&#34;
    return _move(filepath, new_name)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.replace_words_in_files"><code class="name flex">
<span>def <span class="ident">replace_words_in_files</span></span>(<span>pathtosearchin, templateengine, recursive=True, filter=None, minmtime=None, maxmtime=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Replace words in files.</p>
<h2 id="args">Args</h2>
<dl>
<dt>pathtosearchin (str):</dt>
<dt><strong><code>templateengine</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
<dt><strong><code>recursive</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
<dt><strong><code>filter</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>minmtime</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>maxmtime</code></strong> :&ensp;<code>NoneType</code></dt>
<dd>[description]. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def replace_words_in_files(pathtosearchin, templateengine, recursive=True, filter=None, minmtime=None, maxmtime=None):
    &#34;&#34;&#34; Replace words in files.

    Args:
        pathtosearchin (str):
        templateengine (str): [description]
        recursive (bool): [description]. Defaults to True.
        filter (NoneType): [description]. Defaults to None.
        minmtime (NoneType): [description]. Defaults to None.
        maxmtime (NoneType): [description]. Defaults to None.

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    paths = list_files_in_dir(pathtosearchin, recursive, filter, minmtime, maxmtime)
    for path in paths:
        templateengine.replaceInsideFile(path)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.stat_path"><code class="name flex">
<span>def <span class="ident">stat_path</span></span>(<span>path, follow_symlinks=True)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>follow_symlinks</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def stat_path(path, follow_symlinks=True):
    &#34;&#34;&#34;[summary]

Args:
    path ([type]): [description]
    follow_symlinks (bool, optional): [description]. Defaults to True.

Raises:
    j.exceptions.Value: [description]
    j.exceptions.Value: [description]
    Exception: [description]
    Exception: [description]
    j.exceptions.NotImplemented: [description]
    j.exceptions.RuntimeError: [description]

Returns:
    [type]: [description]
&#34;&#34;&#34;
    return os.stat(path, follow_symlinks=follow_symlinks)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.symlink"><code class="name flex">
<span>def <span class="ident">symlink</span></span>(<span>path, target, overwritetarget=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a symbolic link.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Source path desired to create symbolic link.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>destination path required to create the symbolic link.</dd>
<dt><strong><code>overwritetarget</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to False.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def symlink(path, target, overwritetarget=False):
    &#34;&#34;&#34; Create a symbolic link.

    Args:
        path (str): Source path desired to create symbolic link.
        target (str): destination path required to create the symbolic link.
        overwritetarget (bool): [description]. Defaults to False.
    &#34;&#34;&#34;
    if target[-1] == &#34;/&#34;:
        target = target[:-1]

    if overwritetarget and exists(target):
        if is_link(target):
            remove(target)
        elif is_dir(target):
            remove(target)
        else:
            remove(target)

    if os.path.islink(target):
        remove(target)

    dir = get_dir_name(target)
    if not exists(dir):
        create_dir(dir)

    if j.data.platform.is_linux() or j.data.platform.is_osx():
        try:
            os.symlink(path, target)
        except Exception as e:
            os.remove(target)
            os.symlink(path, target)

    elif j.data.platform.is_windows():
        path = path.replace(&#34;+&#34;, &#34;:&#34;)
        cmd = &#39;junction &#34;%s&#34; &#34;%s&#34;&#39; % (
            path_normalize(target).replace(&#34;\\&#34;, &#34;/&#34;),
            path_normalize(path).replace(&#34;\\&#34;, &#34;/&#34;),
        )
        print(cmd)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.symlink_files_in_dir"><code class="name flex">
<span>def <span class="ident">symlink_files_in_dir</span></span>(<span>src, dest, delete=True, includedirs=False, makeexecutable=False)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>src</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>dest</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>delete</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
<dt><strong><code>includedirs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
<dt><strong><code>makeExecutable</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def symlink_files_in_dir(src, dest, delete=True, includedirs=False, makeexecutable=False):
    &#34;&#34;&#34;[summary]

    Args:
        src ([type]): [description]
        dest ([type]): [description]
        delete (bool, optional): [description]. Defaults to True.
        includedirs (bool, optional): [description]. Defaults to False.
        makeExecutable (bool, optional): [description]. Defaults to False.
    &#34;&#34;&#34;
    if includedirs:
        items = list_files_and_dirs_in_dir(src, recursive=False, followsymlinks=False, listsymlinks=False)
    else:
        items = list_files_in_dir(src, recursive=False, followsymlinks=True, listsymlinks=True)
    for item in items:
        dest2 = &#34;%s/%s&#34; % (dest, get_base_name(item))
        dest2 = dest2.replace(&#34;//&#34;, &#34;/&#34;)

        symlink(item, dest2, overwritetarget=delete)
        if makeexecutable:
            # print(&#34;executable:%s&#34; % dest2)
            chmod(dest2, 0o770)
            chmod(item, 0o770)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.targz_compress"><code class="name flex">
<span>def <span class="ident">targz_compress</span></span>(<span>sourcepath, destinationpath, followlinks=False, destintar='', pathregexincludes=['.[a-zA-Z0-9]*'], pathRegexExcludes=[], contentregexincludes=[], contentregexexcludes=[], depths=[], extrafiles=[])</span>
</code></dt>
<dd>
<section class="desc"><p>Compress targz.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sourcepath</code></strong> :&ensp;<code>str</code></dt>
<dd>Source directory.</dd>
<dt><strong><code>destinationpath</code></strong> :&ensp;<code>str</code></dt>
<dd>Destination filename.</dd>
<dt><strong><code>followlinks</code></strong> :&ensp;<code>bool</code></dt>
<dd>do not tar the links, follow the link and add that file or content of directory to the tar. Defaults to False.</dd>
<dt><strong><code>destintar</code></strong> :&ensp;<code>str</code></dt>
<dd>Defaults to "".</dd>
<dt><strong><code>pathregexincludes</code></strong> :&ensp;<code>list</code></dt>
<dd>Defaults to [".[a-zA-Z0-9]*"].</dd>
<dt><strong><code>pathRegexExcludes</code></strong> :&ensp;<code>list</code></dt>
<dd>[description]. Defaults to [].</dd>
<dt><strong><code>contentregexincludes</code></strong> :&ensp;<code>list</code></dt>
<dd>[description]. Defaults to [].</dd>
<dt><strong><code>contentregexexcludes</code></strong> :&ensp;<code>list</code></dt>
<dd>[description]. Defaults to [].</dd>
<dt><strong><code>depths</code></strong> :&ensp;<code>list</code></dt>
<dd>[description]. Defaults to [].</dd>
<dt><strong><code>extrafiles</code></strong> :&ensp;<code>list</code></dt>
<dd>Adds extra files to tar. Defaults to [].</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.RuntimeError</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def targz_compress(
    sourcepath,
    destinationpath,
    followlinks=False,
    destintar=&#34;&#34;,
    pathregexincludes=[&#34;.[a-zA-Z0-9]*&#34;],
    pathRegexExcludes=[],
    contentregexincludes=[],
    contentregexexcludes=[],
    depths=[],
    extrafiles=[],
):
    &#34;&#34;&#34; Compress targz.

    Args:
        sourcepath (str): Source directory.
        destinationpath (str): Destination filename.
        followlinks (bool):  do not tar the links, follow the link and add that file or content of directory to the tar. Defaults to False.
        destintar (str):  Defaults to &#34;&#34;.
        pathregexincludes (list): Defaults to [&#34;.[a-zA-Z0-9]*&#34;].
        pathRegexExcludes (list): [description]. Defaults to [].
        contentregexincludes (list): [description]. Defaults to [].
        contentregexexcludes (list): [description]. Defaults to [].
        depths (list): [description]. Defaults to [].
        extrafiles (list): Adds extra files to tar. Defaults to [].

    Raises:
        j.exceptions.RuntimeError: [description]
    &#34;&#34;&#34;
    import os.path
    import tarfile

    if not exists(get_dir_name(destinationpath)):
        create_dir(get_dir_name(destinationpath))
    t = tarfile.open(name=destinationpath, mode=&#34;w:gz&#34;)
    if not (
        followlinks
        or destintar != &#34;&#34;
        or pathregexincludes != [&#34;.*&#34;]
        or pathRegexExcludes != []
        or contentregexincludes != []
        or contentregexexcludes != []
        or depths != []
    ):
        t.add(sourcepath, &#34;/&#34;)
    else:

        def addToTar(params, path):
            tarfile = params[&#34;t&#34;]
            destintar = params[&#34;destintar&#34;]
            destpath = join_path(destintar, path_remove_dir_part(path, sourcepath))
            if is_link(path) and followlinks:
                path = read_link(path)

            # print &#34;fstar: add file %s to tar&#34; % path
            if not (j.data.platform.is_windows() and j.sals.windows.checkFileToIgnore(path)):
                if is_file(path) or is_link(path):
                    tarfile.add(path, destpath)
                else:
                    raise RuntimeError(&#34;Cannot add file %s to destpath&#34; % destpath)

        params = {}
        params[&#34;t&#34;] = t
        params[&#34;destintar&#34;] = destintar
        j.sals.fswalker.walk(
            root=sourcepath,
            callback=addToTar,
            arg=params,
            recursive=True,
            includeFolders=False,
            pathregexincludes=pathregexincludes,
            pathRegexExcludes=pathRegexExcludes,
            contentregexincludes=contentregexincludes,
            contentregexexcludes=contentregexexcludes,
            depths=depths,
            followlinks=False,
        )

        if extrafiles != []:
            for extrafile in extrafiles:
                source = extrafile[0]
                destpath = extrafile[1]
                t.add(source, join_path(destintar, destpath))
    t.close()</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.targz_uncompress"><code class="name flex">
<span>def <span class="ident">targz_uncompress</span></span>(<span>sourcefile, destinationdir, removedestinationdir=True)</span>
</code></dt>
<dd>
<section class="desc"><p>compress dirname recursive</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sourcefile</code></strong> :&ensp;<code>str</code></dt>
<dd>file to uncompress.</dd>
<dt><strong><code>destinationdir</code></strong> :&ensp;<code>str</code></dt>
<dd>path of the destiniation directory.</dd>
<dt><strong><code>removedestinationdir</code></strong> :&ensp;<code>bool</code></dt>
<dd>[description]. Defaults to True.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def targz_uncompress(sourcefile, destinationdir, removedestinationdir=True):
    &#34;&#34;&#34; compress dirname recursive

    Args:
        sourcefile (str): file to uncompress.
        destinationdir (str): path of the destiniation directory.
        removedestinationdir (bool): [description]. Defaults to True.
    &#34;&#34;&#34;
    if removedestinationdir:
        remove(destinationdir)
    if not exists(destinationdir):
        create_dir(destinationdir)
    import tarfile

    # The tar of python does not create empty directories.. this causes
    # many problem while installing so we choose to use the linux tar here
    if j.data.platform.is_windows():
        tar = tarfile.open(sourcefile)
        tar.extractall(destinationdir)
        tar.close()
        # todo find better alternative for windows
    else:
        cmd = &#34;tar xzf &#39;%s&#39; -C &#39;%s&#39;&#34; % (sourcefile, destinationdir)
        j.sals.process.execute(cmd)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.touch"><code class="name flex">
<span>def <span class="ident">touch</span></span>(<span>paths)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def touch(paths):
    &#34;&#34;&#34;[summary]

   Args:
       paths ([type]): [description]
    &#34;&#34;&#34;
    if isinstance(paths, list):
        for item in paths:
            touch(item)
    else:
        path = paths
        create_dir(get_dir_name(path))
        if not exists(path=path):
            writefile(path, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.unlink"><code class="name flex">
<span>def <span class="ident">unlink</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove the given file if it's a file or a symlink
@param filename: File path to be removed
@type filename: string</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def unlink(filename):
    &#34;&#34;&#34;Remove the given file if it&#39;s a file or a symlink
    @param filename: File path to be removed
    @type filename: string
    &#34;&#34;&#34;

    if j.data.platform.is_windows():
        cmd = &#34;junction -d %s 2&gt;&amp;1 &gt; null&#34; % (filename)
        # _log_info(cmd)
        os.system(cmd)
    os.unlink(filename)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.unlink_file"><code class="name flex">
<span>def <span class="ident">unlink_file</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def unlink_file(filename):
    &#34;&#34;&#34;[summary]

    Args:
        filename ([type]): [description]
    &#34;&#34;&#34;
    if j.data.platform.is_windows():
        cmd = &#34;junction -d %s 2&gt;&amp;1 &gt; null&#34; % (filename)
        # _log_info(cmd)
        os.system(cmd)
    os.unlink(filename)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.validate_filename"><code class="name flex">
<span>def <span class="ident">validate_filename</span></span>(<span>filename, platform=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Validate a filename for a given (or current) platform.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>File name to check.</dd>
<dt><strong><code>platform</code></strong> :&ensp;<code>Nonetype</code></dt>
<dd>Platform to validate against. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.NotImplemented</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>Whether the filename is valid on the given platform</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def validate_filename(filename, platform=None):
    &#34;&#34;&#34; Validate a filename for a given (or current) platform.

    Args:
        filename (str): File name to check.
        platform (Nonetype): Platform to validate against. Defaults to None.

    Raises:
        j.exceptions.NotImplemented: [description]

    Returns:
        bool: Whether the filename is valid on the given platform
    &#34;&#34;&#34;
    platform = platform or j.core.platformtype.myplatform

    if not filename:
        return False</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.write_object_to_file"><code class="name flex">
<span>def <span class="ident">write_object_to_file</span></span>(<span>filelocation, obj)</span>
</code></dt>
<dd>
<section class="desc"><p>write an object to a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filelocation</code></strong> :&ensp;<code>str</code></dt>
<dd>location of the file.</dd>
</dl>
<p>obj (str):</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
<dt><strong><code>Exception</code></strong></dt>
<dd>[description]</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_object_to_file(filelocation, obj):
    &#34;&#34;&#34;write an object to a file

    Args:
        filelocation (str): location of the file.
        obj (str):

    Raises:
        j.exceptions.Value: [description]
        Exception: [description]
        Exception: [description]
    &#34;&#34;&#34;
    if not obj:
        raise RuntimeError(&#34;You should provide a filelocation or a object as parameters&#34;)

    try:
        pcl = pickle.dumps(obj)
    except Exception as e:
        raise Exception(&#34;Could not create pickle from the object \nError: %s&#34; % (str(e)))
    writefile(filelocation, pcl)
    if not exists(filelocation):
        raise Exception(&#34;File isn&#39;t written to the filesystem&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.fs.fs.writefile"><code class="name flex">
<span>def <span class="ident">writefile</span></span>(<span>filename, contents, append=False)</span>
</code></dt>
<dd>
<section class="desc"><p>[summary]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>contents</code></strong> :&ensp;[<code>type</code>]</dt>
<dd>[description]</dd>
<dt><strong><code>append</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>j.exceptions.Value</code>: [<code>description</code>]</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def writefile(filename, contents, append=False):
    &#34;&#34;&#34;[summary]

   Args:
       filename ([type]): [description]
       contents ([type]): [description]
       append (bool, optional): [description]. Defaults to False.

   Raises:
       j.exceptions.Value: [description]
    &#34;&#34;&#34;
    if contents is None:
        raise RuntimeError(&#34;Passed None parameters in system.fs.writefile&#34;)
    # filename = j.core.tools.text_replace(filename)
    if append is False:
        fp = open(filename, &#34;wb&#34;)
    else:
        fp = open(filename, &#34;ab&#34;)

    if isinstance(contents, str):
        fp.write(bytes(contents, &#34;UTF-8&#34;))
    else:
        fp.write(contents)
    # fp.write(contents)
    fp.close()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.sals.fs" href="index.html">jumpscale.sals.fs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="jumpscale.sals.fs.fs.change_dir" href="#jumpscale.sals.fs.fs.change_dir">change_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.change_file_names" href="#jumpscale.sals.fs.fs.change_file_names">change_file_names</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.check_dir_param" href="#jumpscale.sals.fs.fs.check_dir_param">check_dir_param</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.check_unix" href="#jumpscale.sals.fs.fs.check_unix">check_unix</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.check_windows" href="#jumpscale.sals.fs.fs.check_windows">check_windows</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.chmod" href="#jumpscale.sals.fs.fs.chmod">chmod</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.chown" href="#jumpscale.sals.fs.fs.chown">chown</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.construct_dir_path_from_array" href="#jumpscale.sals.fs.fs.construct_dir_path_from_array">construct_dir_path_from_array</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.construct_file_path_from_array" href="#jumpscale.sals.fs.fs.construct_file_path_from_array">construct_file_path_from_array</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.copy_dir_tree" href="#jumpscale.sals.fs.fs.copy_dir_tree">copy_dir_tree</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.copy_file" href="#jumpscale.sals.fs.fs.copy_file">copy_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.create_dir" href="#jumpscale.sals.fs.fs.create_dir">create_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.create_empty_file" href="#jumpscale.sals.fs.fs.create_empty_file">create_empty_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.exists" href="#jumpscale.sals.fs.fs.exists">exists</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.file_size" href="#jumpscale.sals.fs.fs.file_size">file_size</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.find" href="#jumpscale.sals.fs.fs.find">find</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_base_name" href="#jumpscale.sals.fs.fs.get_base_name">get_base_name</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_dir_name" href="#jumpscale.sals.fs.fs.get_dir_name">get_dir_name</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_file_extension" href="#jumpscale.sals.fs.fs.get_file_extension">get_file_extension</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_folder_md5sum" href="#jumpscale.sals.fs.fs.get_folder_md5sum">get_folder_md5sum</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_parent" href="#jumpscale.sals.fs.fs.get_parent">get_parent</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_parent_with_dir_name" href="#jumpscale.sals.fs.fs.get_parent_with_dir_name">get_parent_with_dir_name</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_path_of_running_function" href="#jumpscale.sals.fs.fs.get_path_of_running_function">get_path_of_running_function</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_tmp_dir_path" href="#jumpscale.sals.fs.fs.get_tmp_dir_path">get_tmp_dir_path</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.get_tmp_file_path" href="#jumpscale.sals.fs.fs.get_tmp_file_path">get_tmp_file_path</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.getcwd" href="#jumpscale.sals.fs.fs.getcwd">getcwd</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.grep" href="#jumpscale.sals.fs.fs.grep">grep</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.gunzip" href="#jumpscale.sals.fs.fs.gunzip">gunzip</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.gzip" href="#jumpscale.sals.fs.fs.gzip">gzip</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.hardlink_file" href="#jumpscale.sals.fs.fs.hardlink_file">hardlink_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_absolute" href="#jumpscale.sals.fs.fs.is_absolute">is_absolute</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_asxii_file" href="#jumpscale.sals.fs.fs.is_asxii_file">is_asxii_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_binary_file" href="#jumpscale.sals.fs.fs.is_binary_file">is_binary_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_dir" href="#jumpscale.sals.fs.fs.is_dir">is_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_empty_dir" href="#jumpscale.sals.fs.fs.is_empty_dir">is_empty_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_executable" href="#jumpscale.sals.fs.fs.is_executable">is_executable</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_file" href="#jumpscale.sals.fs.fs.is_file">is_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_link" href="#jumpscale.sals.fs.fs.is_link">is_link</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_link_and_broken" href="#jumpscale.sals.fs.fs.is_link_and_broken">is_link_and_broken</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.is_mount" href="#jumpscale.sals.fs.fs.is_mount">is_mount</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.join_path" href="#jumpscale.sals.fs.fs.join_path">join_path</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.list_dirs_in_dir" href="#jumpscale.sals.fs.fs.list_dirs_in_dir">list_dirs_in_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.list_files_and_dirs_in_dir" href="#jumpscale.sals.fs.fs.list_files_and_dirs_in_dir">list_files_and_dirs_in_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.list_files_in_dir" href="#jumpscale.sals.fs.fs.list_files_in_dir">list_files_in_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.list_py_scripts_in_dir" href="#jumpscale.sals.fs.fs.list_py_scripts_in_dir">list_py_scripts_in_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.md5sum" href="#jumpscale.sals.fs.fs.md5sum">md5sum</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.move_dir" href="#jumpscale.sals.fs.fs.move_dir">move_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.move_file" href="#jumpscale.sals.fs.fs.move_file">move_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.path_clean" href="#jumpscale.sals.fs.fs.path_clean">path_clean</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.path_dir_clean" href="#jumpscale.sals.fs.fs.path_dir_clean">path_dir_clean</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.path_normalize" href="#jumpscale.sals.fs.fs.path_normalize">path_normalize</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.path_remove_dir_part" href="#jumpscale.sals.fs.fs.path_remove_dir_part">path_remove_dir_part</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.path_to_unicode" href="#jumpscale.sals.fs.fs.path_to_unicode">path_to_unicode</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.process_path_for_double_dots" href="#jumpscale.sals.fs.fs.process_path_for_double_dots">process_path_for_double_dots</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.read_link" href="#jumpscale.sals.fs.fs.read_link">read_link</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.read_object_from_file" href="#jumpscale.sals.fs.fs.read_object_from_file">read_object_from_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.readfile" href="#jumpscale.sals.fs.fs.readfile">readfile</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.remove" href="#jumpscale.sals.fs.fs.remove">remove</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.remove_irrelevant_files" href="#jumpscale.sals.fs.fs.remove_irrelevant_files">remove_irrelevant_files</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.remove_links" href="#jumpscale.sals.fs.fs.remove_links">remove_links</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.rename_dir" href="#jumpscale.sals.fs.fs.rename_dir">rename_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.rename_file" href="#jumpscale.sals.fs.fs.rename_file">rename_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.replace_words_in_files" href="#jumpscale.sals.fs.fs.replace_words_in_files">replace_words_in_files</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.stat_path" href="#jumpscale.sals.fs.fs.stat_path">stat_path</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.symlink" href="#jumpscale.sals.fs.fs.symlink">symlink</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.symlink_files_in_dir" href="#jumpscale.sals.fs.fs.symlink_files_in_dir">symlink_files_in_dir</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.targz_compress" href="#jumpscale.sals.fs.fs.targz_compress">targz_compress</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.targz_uncompress" href="#jumpscale.sals.fs.fs.targz_uncompress">targz_uncompress</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.touch" href="#jumpscale.sals.fs.fs.touch">touch</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.unlink" href="#jumpscale.sals.fs.fs.unlink">unlink</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.unlink_file" href="#jumpscale.sals.fs.fs.unlink_file">unlink_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.validate_filename" href="#jumpscale.sals.fs.fs.validate_filename">validate_filename</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.write_object_to_file" href="#jumpscale.sals.fs.fs.write_object_to_file">write_object_to_file</a></code></li>
<li><code><a title="jumpscale.sals.fs.fs.writefile" href="#jumpscale.sals.fs.fs.writefile">writefile</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>